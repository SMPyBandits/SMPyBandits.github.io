

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38514290-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Policies.SlidingWindowRestart &mdash; SMPyBandits 0.9.6 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> SMPyBandits
          

          
            
            <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html"><em>SMPyBandits</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs/modules.html">SMPyBandits modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../How_to_run_the_code.html">How to run the code ?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PublicationsWithSMPyBandits.html">List of research publications using Lilian Bessonâ€™s SMPyBandits project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Aggregation.html"><strong>Policy aggregation algorithms</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MultiPlayers.html"><strong>Multi-players simulation environment</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DoublingTrick.html"><strong>Doubling Trick for Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../SparseBandits.html"><strong>Structure and Sparsity of Stochastic Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NonStationaryBandits.html"><strong>Non-Stationary Stochastic Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../API.html">Short documentation of the API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../About_parallel_computations.html">About parallel computations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../TODO.html">ðŸ’¥ TODO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plots/README.html">Some illustrations for this project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/README.html">Jupyter Notebooks ðŸ““ by Naereen &#64; GitHub</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/list.html">List of notebooks for SMPyBandits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Profiling.html">A note on execution times, speed and profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../uml_diagrams/README.html">UML diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../logs/README.html"><code class="docutils literal notranslate"><span class="pre">logs</span></code> files</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SMPyBandits</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>Policies.SlidingWindowRestart</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for Policies.SlidingWindowRestart</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot; An experimental policy, using a sliding window (of for instance :math:`\tau=100` *draws* of each arm), and reset the algorithm as soon as the small empirical average is too far away from the long history empirical average (or just restart for one arm, if possible).</span>

<span class="sd">- Reference: none yet, idea from RÃ©mi Bonnefoi and Lilian Besson.</span>
<span class="sd">- It runs on top of a simple policy, e.g., :class:`UCB`, and :func:`SlidingWindowRestart` is a generic policy using any simple policy with this &quot;sliding window&quot; trick:</span>

<span class="sd">    &gt;&gt;&gt; policy = SlidingWindowRestart(nbArms, UCB, tau=100, threshold=0.1)</span>
<span class="sd">    &gt;&gt;&gt; # use policy as usual, with policy.startGame(), r = policy.choice(), policy.getReward(arm, r)</span>

<span class="sd">- It uses an additional :math:`\mathcal{O}(\tau)` memory but do not cost anything else in terms of time complexity (the average is done with a sliding window, and costs :math:`\mathcal{O}(1)` at every time step).</span>

<span class="sd">.. warning:: This is very experimental!</span>
<span class="sd">.. warning:: It can only work on basic index policy based on empirical averages (and an exploration bias), like :class:`UCB`, and cannot work on any Bayesian policy (for which we would have to remember all previous observations in order to reset the history with a small history)! Note that it works on :class:`Policies.Thompson.Thompson`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>  <span class="c1"># Python 2 compatibility</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;RÃ©mi Bonnefoi and Lilian Besson&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.9&quot;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.BaseWrapperPolicy</span> <span class="k">import</span> <span class="n">BaseWrapperPolicy</span>
    <span class="kn">from</span> <span class="nn">.UCB</span> <span class="k">import</span> <span class="n">UCB</span> <span class="k">as</span> <span class="n">DefaultPolicy</span><span class="p">,</span> <span class="n">UCB</span>
    <span class="kn">from</span> <span class="nn">.UCBalpha</span> <span class="k">import</span> <span class="n">UCBalpha</span><span class="p">,</span> <span class="n">ALPHA</span>
    <span class="kn">from</span> <span class="nn">.klUCB</span> <span class="k">import</span> <span class="n">klUCB</span><span class="p">,</span> <span class="n">klucbBern</span><span class="p">,</span> <span class="n">c</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">BaseWrapperPolicy</span> <span class="k">import</span> <span class="n">BaseWrapperPolicy</span>
    <span class="kn">from</span> <span class="nn">UCB</span> <span class="k">import</span> <span class="n">UCB</span> <span class="k">as</span> <span class="n">DefaultPolicy</span><span class="p">,</span> <span class="n">UCB</span>
    <span class="kn">from</span> <span class="nn">UCBalpha</span> <span class="k">import</span> <span class="n">UCBalpha</span><span class="p">,</span> <span class="n">ALPHA</span>
    <span class="kn">from</span> <span class="nn">klUCB</span> <span class="k">import</span> <span class="n">klUCB</span><span class="p">,</span> <span class="n">klucbBern</span><span class="p">,</span> <span class="n">c</span>


<span class="c1">#: Size of the sliding window.</span>
<span class="n">TAU</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1">#: Threshold to know when to restart the base algorithm.</span>
<span class="n">THRESHOLD</span> <span class="o">=</span> <span class="mf">0.005</span>

<span class="c1">#: Should we fully restart the algorithm or simply reset one arm empirical average ?</span>
<span class="n">FULL_RESTART_WHEN_REFRESH</span> <span class="o">=</span> <span class="kc">True</span>


<span class="c1"># --- Class</span>

<div class="viewcode-block" id="SlidingWindowRestart"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SlidingWindowRestart">[docs]</a><span class="k">class</span> <span class="nc">SlidingWindowRestart</span><span class="p">(</span><span class="n">BaseWrapperPolicy</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; An experimental policy, using a sliding window of for instance :math:`\tau=100` draws, and reset the algorithm as soon as the small empirical average is too far away from the full history empirical average (or just restart for one arm, if possible).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SlidingWindowRestart.__init__"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SlidingWindowRestart.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbArms</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">DefaultPolicy</span><span class="p">,</span>
            <span class="n">tau</span><span class="o">=</span><span class="n">TAU</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">THRESHOLD</span><span class="p">,</span> <span class="n">full_restart_when_refresh</span><span class="o">=</span><span class="n">FULL_RESTART_WHEN_REFRESH</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SlidingWindowRestart</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">policy</span><span class="o">=</span><span class="n">policy</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># New parameters</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">tau</span><span class="p">,</span> <span class="s2">&quot;Error: parameter &#39;tau&#39; for class SlidingWindowRestart has to be &gt;= 1, but was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1"># Size of the sliding window.</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Error: parameter &#39;threshold&#39; for class SlidingWindowRestart has to be 0 &lt; threshold &lt;= 1, but was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_threshold</span> <span class="o">=</span> <span class="n">threshold</span>  <span class="c1"># Threshold to know when to restart the base algorithm.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_restart_when_refresh</span> <span class="o">=</span> <span class="n">full_restart_when_refresh</span>  <span class="c1"># Should we fully restart the algorithm or simply reset one arm empirical average ?</span>
        <span class="c1"># Internal memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="p">))</span>  <span class="c1">#: Keep in memory all the rewards obtained in the last :math:`\tau` steps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1">#: Keep in memory the times where each arm was last seen. Start with -1 (never seen)</span></div>

<div class="viewcode-block" id="SlidingWindowRestart.__str__"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SlidingWindowRestart.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;SW-Restart(</span><span class="si">{}</span><span class="s2">, $\tau=</span><span class="si">{}</span><span class="s2">$, $\varepsilon=</span><span class="si">{:.3g}</span><span class="s2">$)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_policy</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="SlidingWindowRestart.getReward"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SlidingWindowRestart.getReward">[docs]</a>    <span class="k">def</span> <span class="nf">getReward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arm</span><span class="p">,</span> <span class="n">reward</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give a reward: increase t, pulls, and update cumulated sum of rewards and update small history (sliding window) for that arm (normalized in [0, 1]).</span>

<span class="sd">        - Reset the whole empirical average if the small average is too far away from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SlidingWindowRestart</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">getReward</span><span class="p">(</span><span class="n">arm</span><span class="p">,</span> <span class="n">reward</span><span class="p">)</span>
        <span class="c1"># Get reward</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="p">(</span><span class="n">reward</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="c1"># We seen it one more time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Store it in place for the empirical average of that arm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="p">]</span> <span class="o">=</span> <span class="n">reward</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="p">:</span>
            <span class="c1"># Compute the empirical average for that arm</span>
            <span class="n">empirical_average</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span>
            <span class="c1"># And the small empirical average for that arm</span>
            <span class="n">small_empirical_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">empirical_average</span> <span class="o">-</span> <span class="n">small_empirical_average</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_threshold</span><span class="p">:</span>
                <span class="c1"># Fully restart the algorithm ?!</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_restart_when_refresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">startGame</span><span class="p">(</span><span class="n">createNewPolicy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1"># Or simply reset one of the empirical averages?</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="p">)</span></div></div>


<span class="c1"># --- Manually written</span>

<div class="viewcode-block" id="SWR_UCB"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_UCB">[docs]</a><span class="k">class</span> <span class="nc">SWR_UCB</span><span class="p">(</span><span class="n">UCB</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; An experimental policy, using a sliding window of for instance :math:`\tau=100` draws, and reset the algorithm as soon as the small empirical average is too far away from the full history empirical average (or just restart for one arm, if possible).</span>

<span class="sd">    .. warning:: FIXME I should remove this code, it&#39;s useless now that the generic wrapper :class:`SlidingWindowRestart` works fine.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SWR_UCB.__init__"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_UCB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbArms</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">TAU</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">THRESHOLD</span><span class="p">,</span> <span class="n">full_restart_when_refresh</span><span class="o">=</span><span class="n">FULL_RESTART_WHEN_REFRESH</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SWR_UCB</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nbArms</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># New parameters</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">tau</span><span class="p">,</span> <span class="s2">&quot;Error: parameter &#39;tau&#39; for class SWR_UCB has to be &gt;= 1, but was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1">#: Size of the sliding window.</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Error: parameter &#39;threshold&#39; for class SWR_UCB has to be 0 &lt; threshold &lt;= 1, but was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>  <span class="c1">#: Threshold to know when to restart the base algorithm.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">tau</span><span class="p">))</span>  <span class="c1">#: Keep in memory all the rewards obtained in the last :math:`\tau` steps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1">#: Keep in memory the times where each arm was last seen. Start with -1 (never seen)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_restart_when_refresh</span> <span class="o">=</span> <span class="n">full_restart_when_refresh</span>  <span class="c1">#: Should we fully restart the algorithm or simply reset one arm empirical average ?</span></div>

<div class="viewcode-block" id="SWR_UCB.__str__"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_UCB.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;SW-Restart(</span><span class="si">{}</span><span class="s2">, $\tau=</span><span class="si">{}</span><span class="s2">$, $\varepsilon=</span><span class="si">{:.3g}</span><span class="s2">$)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">SWR_UCB</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWR_UCB.getReward"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_UCB.getReward">[docs]</a>    <span class="k">def</span> <span class="nf">getReward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arm</span><span class="p">,</span> <span class="n">reward</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give a reward: increase t, pulls, and update cumulated sum of rewards and update small history (sliding window) for that arm (normalized in [0, 1]).</span>

<span class="sd">        - Reset the whole empirical average if the small average is too far away from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SWR_UCB</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">getReward</span><span class="p">(</span><span class="n">arm</span><span class="p">,</span> <span class="n">reward</span><span class="p">)</span>
        <span class="c1"># Get reward</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="p">(</span><span class="n">reward</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="c1"># We seen it one more time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Store it in place for the empirical average of that arm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">]</span> <span class="o">=</span> <span class="n">reward</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">:</span>
            <span class="c1"># Compute the empirical average for that arm</span>
            <span class="n">empirical_average</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span>
            <span class="c1"># And the small empirical average for that arm</span>
            <span class="n">small_empirical_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">empirical_average</span> <span class="o">-</span> <span class="n">small_empirical_average</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                <span class="c1"># Fully restart the algorithm ?!</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_restart_when_refresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">startGame</span><span class="p">()</span>
                <span class="c1"># Or simply reset one of the empirical averages?</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SWR_UCBalpha"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_UCBalpha">[docs]</a><span class="k">class</span> <span class="nc">SWR_UCBalpha</span><span class="p">(</span><span class="n">UCBalpha</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; An experimental policy, using a sliding window of for instance :math:`\tau=100` draws, and reset the algorithm as soon as the small empirical average is too far away from the full history empirical average (or just restart for one arm, if possible).</span>

<span class="sd">    .. warning:: FIXME I should remove this code, it&#39;s useless now that the generic wrapper :class:`SlidingWindowRestart` works fine.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SWR_UCBalpha.__init__"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_UCBalpha.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbArms</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">TAU</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">THRESHOLD</span><span class="p">,</span> <span class="n">full_restart_when_refresh</span><span class="o">=</span><span class="n">FULL_RESTART_WHEN_REFRESH</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">ALPHA</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SWR_UCBalpha</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># New parameters</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">tau</span><span class="p">,</span> <span class="s2">&quot;Error: parameter &#39;tau&#39; for class SWR_UCBalpha has to be &gt;= 1, but was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1">#: Size of the sliding window.</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Error: parameter &#39;threshold&#39; for class SWR_UCBalpha has to be 0 &lt; threshold &lt;= 1, but was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>  <span class="c1">#: Threshold to know when to restart the base algorithm.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">tau</span><span class="p">))</span>  <span class="c1">#: Keep in memory all the rewards obtained in the last :math:`\tau` steps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1">#: Keep in memory the times where each arm was last seen. Start with -1 (never seen)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_restart_when_refresh</span> <span class="o">=</span> <span class="n">full_restart_when_refresh</span>  <span class="c1">#: Should we fully restart the algorithm or simply reset one arm empirical average ?</span></div>

<div class="viewcode-block" id="SWR_UCBalpha.__str__"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_UCBalpha.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;SW-Restart(</span><span class="si">{}</span><span class="s2">, $\tau=</span><span class="si">{}</span><span class="s2">$, $\varepsilon=</span><span class="si">{:.3g}</span><span class="s2">$)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">SWR_UCBalpha</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWR_UCBalpha.getReward"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_UCBalpha.getReward">[docs]</a>    <span class="k">def</span> <span class="nf">getReward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arm</span><span class="p">,</span> <span class="n">reward</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give a reward: increase t, pulls, and update cumulated sum of rewards and update small history (sliding window) for that arm (normalized in [0, 1]).</span>

<span class="sd">        - Reset the whole empirical average if the small average is too far away from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SWR_UCBalpha</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">getReward</span><span class="p">(</span><span class="n">arm</span><span class="p">,</span> <span class="n">reward</span><span class="p">)</span>
        <span class="c1"># Get reward</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="p">(</span><span class="n">reward</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="c1"># We seen it one more time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Store it in place for the empirical average of that arm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">]</span> <span class="o">=</span> <span class="n">reward</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">:</span>
            <span class="c1"># Compute the empirical average for that arm</span>
            <span class="n">empirical_average</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span>
            <span class="c1"># And the small empirical average for that arm</span>
            <span class="n">small_empirical_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">empirical_average</span> <span class="o">-</span> <span class="n">small_empirical_average</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                <span class="c1"># Fully restart the algorithm ?!</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_restart_when_refresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">startGame</span><span class="p">()</span>
                <span class="c1"># Or simply reset one of the empirical averages?</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="SWR_klUCB"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_klUCB">[docs]</a><span class="k">class</span> <span class="nc">SWR_klUCB</span><span class="p">(</span><span class="n">klUCB</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; An experimental policy, using a sliding window of for instance :math:`\tau=100` draws, and reset the algorithm as soon as the small empirical average is too far away from the full history empirical average (or just restart for one arm, if possible).</span>

<span class="sd">    .. warning:: FIXME I should remove this code, it&#39;s useless now that the generic wrapper :class:`SlidingWindowRestart` works fine.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SWR_klUCB.__init__"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_klUCB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbArms</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">TAU</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">THRESHOLD</span><span class="p">,</span> <span class="n">full_restart_when_refresh</span><span class="o">=</span><span class="n">FULL_RESTART_WHEN_REFRESH</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">klucb</span><span class="o">=</span><span class="n">klucbBern</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SWR_klUCB</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">klucb</span><span class="o">=</span><span class="n">klucb</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># New parameters</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">tau</span><span class="p">,</span> <span class="s2">&quot;Error: parameter &#39;tau&#39; for class SWR_klUCB has to be &gt;= 1, but was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span>  <span class="c1">#: Size of the sliding window.</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">threshold</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Error: parameter &#39;threshold&#39; for class SWR_klUCB has to be 0 &lt; threshold &lt;= 1, but was </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>  <span class="c1">#: Threshold to know when to restart the base algorithm.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">tau</span><span class="p">))</span>  <span class="c1">#: Keep in memory all the rewards obtained in the last :math:`\tau` steps.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1">#: Keep in memory the times where each arm was last seen. Start with -1 (never seen)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_restart_when_refresh</span> <span class="o">=</span> <span class="n">full_restart_when_refresh</span>  <span class="c1">#: Should we fully restart the algorithm or simply reset one arm empirical average ?</span></div>

<div class="viewcode-block" id="SWR_klUCB.__str__"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_klUCB.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">r</span><span class="s2">&quot;SW-Restart(</span><span class="si">{}</span><span class="s2">, $\tau=</span><span class="si">{}</span><span class="s2">$, $\varepsilon=</span><span class="si">{:.3g}</span><span class="s2">$)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">SWR_klUCB</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="SWR_klUCB.getReward"><a class="viewcode-back" href="../../docs/Policies.SlidingWindowRestart.html#Policies.SlidingWindowRestart.SWR_klUCB.getReward">[docs]</a>    <span class="k">def</span> <span class="nf">getReward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arm</span><span class="p">,</span> <span class="n">reward</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give a reward: increase t, pulls, and update cumulated sum of rewards and update small history (sliding window) for that arm (normalized in [0, 1]).</span>

<span class="sd">        - Reset the whole empirical average if the small average is too far away from it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">SWR_klUCB</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">getReward</span><span class="p">(</span><span class="n">arm</span><span class="p">,</span> <span class="n">reward</span><span class="p">)</span>
        <span class="c1"># Get reward</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="p">(</span><span class="n">reward</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">amplitude</span>
        <span class="c1"># We seen it one more time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Store it in place for the empirical average of that arm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">]</span> <span class="o">=</span> <span class="n">reward</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">:</span>
            <span class="c1"># Compute the empirical average for that arm</span>
            <span class="n">empirical_average</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span>
            <span class="c1"># And the small empirical average for that arm</span>
            <span class="n">small_empirical_average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">empirical_average</span> <span class="o">-</span> <span class="n">small_empirical_average</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                <span class="c1"># Fully restart the algorithm ?!</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_restart_when_refresh</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">startGame</span><span class="p">()</span>
                <span class="c1"># Or simply reset one of the empirical averages?</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_rewards</span><span class="p">[</span><span class="n">arm</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_pulls</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2018, Lilian Besson (Naereen)
      <span class="lastupdated">
        Last updated on 09 Oct 2019, 11h.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>