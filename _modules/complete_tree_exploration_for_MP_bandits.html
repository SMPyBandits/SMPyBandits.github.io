

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38514290-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>complete_tree_exploration_for_MP_bandits &mdash; SMPyBandits 0.9.5 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> SMPyBandits
          

          
            
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html"><em>SMPyBandits</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="../docs/modules.html">SMPyBandits modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../How_to_run_the_code.html">How to run the code ?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../PublicationsWithSMPyBandits.html">List of research publications using Lilian Bessonâ€™s SMPyBandits project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Aggregation.html"><strong>Policy aggregation algorithms</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../MultiPlayers.html"><strong>Multi-players simulation environment</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../DoublingTrick.html"><strong>Doubling Trick for Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../SparseBandits.html"><strong>Structure and Sparsity of Stochastic Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../NonStationaryBandits.html"><strong>Non-Stationary Stochastic Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../API.html">Short documentation of the API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../About_parallel_computations.html">About parallel computations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TODO.html">ðŸ’¥ TODO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../plots/README.html">Some illustrations for this project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/README.html">Jupyter Notebooks ðŸ““ by Naereen &#64; GitHub</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/list.html">List of notebooks for SMPyBandits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Profiling.html">A note on execution times, speed and profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../uml_diagrams/README.html">UML diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../logs/README.html"><code class="docutils literal notranslate"><span class="pre">logs</span></code> files</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SMPyBandits</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>complete_tree_exploration_for_MP_bandits</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for complete_tree_exploration_for_MP_bandits</h1><div class="highlight"><pre>
<span></span><span class="ch">#! /usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8; mode: python -*-</span>
<span class="sa">r</span><span class="sd">&quot;&quot;&quot; Experimental code to perform complete tree exploration for Multi-Player bandits.</span>

<span class="sd">Algorithms:</span>

<span class="sd">- Support Selfish 0-greedy, UCB, and klUCB in 3 different variants.</span>
<span class="sd">- Support also RhoRand, RandTopM and MCTopM, even though they are *not* memory-less, by using another state representation (inlining the memory of each player, eg the ranks for RhoRand).</span>

<span class="sd">Features:</span>

<span class="sd">- For the means of each arm, :math:`\mu_1, \dots, \mu_K`, this script can use exact formal computations with sympy, or fractions with Fraction, or float number.</span>
<span class="sd">- The graph can contain all nodes from root to leafs, or only leafs (with summed probabilities), and possibly only the absorbing nodes are showed.</span>
<span class="sd">- Support export of the tree to a GraphViz dot graph, and can save it to SVG/PNG and LaTeX (with Tikz) and PDF etc.</span>
<span class="sd">- By default, the root is highlighted in green and the absorbing nodes are in red.</span>

<span class="sd">.. warning:: I still have to fix these issues:</span>

<span class="sd">   - TODO : right now, it is not so efficient, could it be improved? I don&#39;t think I can do anything in a smarter way, in pure Python.</span>


<span class="sd">Requirements:</span>

<span class="sd">- &#39;sympy&#39; module to use formal means :math:`\mu_1, \dots, \mu_K` instead of numbers,</span>
<span class="sd">- &#39;numpy&#39; module for computations on indexes (e.g., ``np.where``),</span>
<span class="sd">- &#39;graphviz&#39; module to generate the graph and save it,</span>
<span class="sd">- &#39;dot2tex&#39; module to generate nice LaTeX (with Tikz) graph and save it to PDF.</span>

<span class="sd">.. note::</span>

<span class="sd">   To use the &#39;dot2tex&#39; module, only Python2 is supported.</span>
<span class="sd">   However, I maintain an unpublished port of &#39;dot2tex&#39; for Python3, see</span>
<span class="sd">   [here](https://github.com/Naereen/dot2tex), that you can download, and install</span>
<span class="sd">   manually (sudo python3 setup.py install) to have &#39;dot2tex&#39; for Python3 also.</span>

<span class="sd">About:</span>

<span class="sd">- *Date:* 16/09/2017.</span>
<span class="sd">- *Author:* Lilian Besson, (C) 2017</span>
<span class="sd">- *Licence:* MIT Licence (http://lbesson.mit-license.org).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>  <span class="c1"># Python 2 compatibility</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Lilian Besson&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.7&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="k">import</span> <span class="n">Fraction</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">getenv</span><span class="p">,</span> <span class="n">chdir</span><span class="p">,</span> <span class="n">getcwd</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">join</span> <span class="k">as</span> <span class="n">os_path_join</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="k">import</span> <span class="n">dirname</span><span class="p">,</span> <span class="n">basename</span>
<span class="kn">from</span> <span class="nn">re</span> <span class="k">import</span> <span class="n">sub</span> <span class="k">as</span> <span class="n">re_sub</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="k">import</span> <span class="n">wrap</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: the &#39;numpy&#39; module was not found...</span><span class="se">\n</span><span class="s2">Install it with &#39;sudo pip2/pip3 install numpy&#39; or your system packet manager (eg. &#39;sudo apt install python3-numpy&#39;)&quot;</span><span class="p">)</span>  <span class="c1"># XXX</span>
    <span class="k">raise</span> <span class="n">e</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sympy</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: the &#39;sympy&#39; module was not found...</span><span class="se">\n</span><span class="s2">Symbolic computations cannot be performed without sympy.</span><span class="se">\n</span><span class="s2">Install it with &#39;sudo pip2/pip3 install sympy&#39; or your system packet manager (eg. &#39;sudo apt install python3-sympy&#39;)&quot;</span><span class="p">)</span>  <span class="c1"># XXX</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">graphviz</span> <span class="k">import</span> <span class="n">Digraph</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: the &#39;graphviz&#39; module was not found...</span><span class="se">\n</span><span class="s2">Trees cannot be saved or displayed without graphviz.</span><span class="se">\n</span><span class="s2">Install it with &#39;sudo pip2/pip3 install graphviz&#39;&quot;</span><span class="p">)</span>  <span class="c1"># XXX</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># if version_info.major &lt; 3:</span>
    <span class="kn">from</span> <span class="nn">dot2tex</span> <span class="k">import</span> <span class="n">dot2tex</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: the &#39;dot2tex&#39; module was not found...</span><span class="se">\n</span><span class="s2">Trees cannot be saved to LaTeX and PDF formats.</span><span class="se">\n</span><span class="s2">Install it with &#39;sudo pip2 install dot2tex&#39; (require Python 2)</span><span class="se">\n</span><span class="s2">Or install it from https://github.com/Naereen/dot2tex for Python 3.&quot;</span><span class="p">)</span>  <span class="c1"># XXX</span>

<span class="n">oo</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;+inf&#39;</span><span class="p">)</span>  <span class="c1">#: Shortcut for float(&#39;+inf&#39;).</span>

<span class="kn">from</span> <span class="nn">sys</span> <span class="k">import</span> <span class="n">version_info</span>
<span class="k">if</span> <span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Python 2 compatibility if needed</span>
    <span class="nb">input</span> <span class="o">=</span> <span class="n">raw_input</span>
    <span class="kn">import</span> <span class="nn">codecs</span>
    <span class="k">def</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>  <span class="c1"># https://docs.python.org/3/library/codecs.html#standard-encodings</span>
        <span class="k">return</span> <span class="n">codecs</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf_8&#39;</span><span class="p">)</span>

<span class="n">PLOT_DIR</span> <span class="o">=</span> <span class="n">os_path_join</span><span class="p">(</span><span class="s2">&quot;plots&quot;</span><span class="p">,</span> <span class="s2">&quot;trees&quot;</span><span class="p">)</span>  <span class="c1">#: Directory for the plots</span>

<span class="kn">from</span> <span class="nn">Arms.usenumba</span> <span class="k">import</span> <span class="n">jit</span>

<div class="viewcode-block" id="tupleit1"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.tupleit1">[docs]</a><span class="k">def</span> <span class="nf">tupleit1</span><span class="p">(</span><span class="n">anarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a non-hashable 1D numpy array to a hashable tuple.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">anarray</span><span class="p">))</span></div>

<div class="viewcode-block" id="tupleit2"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.tupleit2">[docs]</a><span class="k">def</span> <span class="nf">tupleit2</span><span class="p">(</span><span class="n">anarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a non-hashable 2D numpy array to a hashable tuple-of-tuples.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">anarray</span><span class="p">)])</span></div>

<div class="viewcode-block" id="prod"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.prod">[docs]</a><span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Product of the values in this iterator.&quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">*=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">p</span></div>


<span class="n">WIDTH</span> <span class="o">=</span> <span class="mi">200</span>  <span class="c1">#: Default value for the ``width`` parameter for :func:`wraptext` and :func:`wraplatex`.</span>

<div class="viewcode-block" id="wraptext"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.wraptext">[docs]</a><span class="k">def</span> <span class="nf">wraptext</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">WIDTH</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Wrap the text, using ``textwrap`` module, and ``width``.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">wrap</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">))</span></div>


<div class="viewcode-block" id="mybool"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.mybool">[docs]</a><span class="k">def</span> <span class="nf">mybool</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span> <span class="k">else</span> <span class="nb">bool</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<span class="n">ONLYLEAFS</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1">#: By default, aim at the most concise graph representation by only showing the leafs.</span>
<span class="n">ONLYLEAFS</span> <span class="o">=</span> <span class="n">mybool</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;ONLYLEAFS&#39;</span><span class="p">,</span> <span class="n">ONLYLEAFS</span><span class="p">))</span>

<span class="n">ONLYABSORBING</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: By default, don&#39;t aim at the most concise graph representation by only showing the absorbing leafs.</span>
<span class="n">ONLYABSORBING</span> <span class="o">=</span> <span class="n">mybool</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;ONLYABSORBING&#39;</span><span class="p">,</span> <span class="n">ONLYABSORBING</span><span class="p">))</span>

<span class="n">CONCISE</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1">#: By default, only show :math:`\tilde{S}` and :math:`N` in the graph representations, not all the 4 vectors.</span>
<span class="n">CONCISE</span> <span class="o">=</span> <span class="n">mybool</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;CONCISE&#39;</span><span class="p">,</span> <span class="n">CONCISE</span><span class="p">))</span>

<span class="n">FULLHASH</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">CONCISE</span>  <span class="c1">#: Use only Stilde, N for hashing the states.</span>
<span class="n">FULLHASH</span> <span class="o">=</span> <span class="n">mybool</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;FULLHASH&#39;</span><span class="p">,</span> <span class="n">FULLHASH</span><span class="p">))</span>

<span class="c1"># FORMAT = &quot;pdf&quot;  #: Format used to save the graphs.</span>
<span class="n">FORMAT</span> <span class="o">=</span> <span class="s2">&quot;svg&quot;</span>  <span class="c1">#: Format used to save the graphs.</span>
<span class="n">FORMAT</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;FORMAT&quot;</span><span class="p">,</span> <span class="n">FORMAT</span><span class="p">)</span>

<span class="c1"># --- Implement the bandit algorithms in a purely functional and memory-less flavor</span>

<div class="viewcode-block" id="FixedArm"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.FixedArm">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">FixedArm</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fake player j that always targets at arm j.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">j</span><span class="p">]</span></div>

<div class="viewcode-block" id="UniformExploration"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.UniformExploration">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">UniformExploration</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fake player j that always targets all arms.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">K</span><span class="p">))</span></div>

<div class="viewcode-block" id="ConstantRank"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.ConstantRank">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">ConstantRank</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">collision</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constant rank no matter what.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span></div>

<div class="viewcode-block" id="choices_from_indexes"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.choices_from_indexes">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For deterministic index policies, if more than one index is maximum, return the list of positions attaining this maximum (ties), or only one position.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indexes</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indexes</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>

<span class="c1"># --- Selfish 0-greedy variants</span>

<div class="viewcode-block" id="Selfish_0Greedy_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_0Greedy_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_0Greedy_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + 0-Greedy index + U feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Selfish_0Greedy_Utilde"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_0Greedy_Utilde">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_0Greedy_Utilde</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + 0-Greedy index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Selfish_0Greedy_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_0Greedy_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_0Greedy_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + 0-Greedy index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<span class="n">default_policy</span> <span class="o">=</span> <span class="n">Selfish_0Greedy_Ubar</span>


<span class="c1"># --- Selfish UCB variants</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>

<div class="viewcode-block" id="Selfish_UCB_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_UCB_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_UCB_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + UCB_0.5 index + U feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Selfish_UCB"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_UCB">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_UCB</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + UCB_0.5 index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<span class="n">Selfish_UCB_Utilde</span> <span class="o">=</span> <span class="n">Selfish_UCB</span>

<div class="viewcode-block" id="Selfish_UCB_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_UCB_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_UCB_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + UCB_0.5 index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<span class="c1"># default_policy = Selfish_UCB_Ubar</span>

<span class="c1"># --- Selfish kl UCB variants</span>

<span class="kn">from</span> <span class="nn">Policies</span> <span class="k">import</span> <span class="n">klucbBern</span>
<span class="n">tolerance</span> <span class="o">=</span> <span class="mf">1e-6</span>
<span class="n">klucb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">klucbBern</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>

<div class="viewcode-block" id="Selfish_KLUCB_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_KLUCB_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_KLUCB_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + Bernoulli KL-UCB index + U feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Selfish_KLUCB"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_KLUCB">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_KLUCB</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + Bernoulli KL-UCB index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<span class="n">Selfish_KLUCB_Utilde</span> <span class="o">=</span> <span class="n">Selfish_KLUCB</span>

<div class="viewcode-block" id="Selfish_KLUCB_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.Selfish_KLUCB_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">Selfish_KLUCB_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Selfish policy + Bernoulli KL-UCB index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">((</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span></div>

<span class="c1"># default_policy = Selfish_KLUCB_Ubar</span>


<span class="c1"># --- RhoRand UCB variants</span>

<div class="viewcode-block" id="choices_from_indexes_with_rank"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.choices_from_indexes_with_rank">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">choices_from_indexes_with_rank</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For deterministic index policies, if more than one index is maximum, return the list of positions attaining the rank-th largest index (with more than one if ties, or only one position).&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indexes</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">rank</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span></div>

<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>

<div class="viewcode-block" id="RhoRand_UCB_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RhoRand_UCB_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RhoRand_UCB_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RhoRand policy + UCB_0.5 index + U feedback.&quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes_with_rank</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">)</span></div>

<div class="viewcode-block" id="RhoRand_UCB_Utilde"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RhoRand_UCB_Utilde">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RhoRand_UCB_Utilde</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RhoRand policy + UCB_0.5 index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes_with_rank</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">)</span></div>

<div class="viewcode-block" id="RhoRand_UCB_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RhoRand_UCB_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RhoRand_UCB_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RhoRand policy + UCB_0.5 index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes_with_rank</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">)</span></div>

<div class="viewcode-block" id="RhoRand_KLUCB_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RhoRand_KLUCB_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RhoRand_KLUCB_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RhoRand policy + Bernoulli KL-UCB index + U feedback.&quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes_with_rank</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">)</span></div>

<div class="viewcode-block" id="RhoRand_KLUCB_Utilde"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RhoRand_KLUCB_Utilde">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RhoRand_KLUCB_Utilde</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RhoRand policy + Bernoulli KL-UCB index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes_with_rank</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">)</span></div>

<div class="viewcode-block" id="RhoRand_KLUCB_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RhoRand_KLUCB_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RhoRand_KLUCB_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RhoRand policy + Bernoulli KL-UCB index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">((</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="k">return</span> <span class="n">choices_from_indexes_with_rank</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="n">rank</span><span class="p">)</span></div>

<span class="c1"># So we need tow functions: one takes the decision, one updates the rank after all the decisions are taken</span>

<div class="viewcode-block" id="RandomNewRank"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RandomNewRank">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RandomNewRank</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">collision</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RhoRand chooses a new uniform rank in {1,..,M} in case of collision, or keep the same.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">collision</span><span class="p">:</span>  <span class="c1"># new random rank</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># keep the same rank</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span></div>

<span class="n">default_policy</span><span class="p">,</span> <span class="n">default_update_memory</span> <span class="o">=</span> <span class="n">RhoRand_UCB_U</span><span class="p">,</span> <span class="n">RandomNewRank</span>
<span class="c1"># default_policy, default_update_memory = RhoRand_KLUCB_U, RandomNewRank</span>


<span class="c1"># --- RandTopM, MCTopM variants</span>

<div class="viewcode-block" id="RandTopM_UCB_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RandTopM_UCB_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RandTopM_UCB_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RandTopM policy + UCB_0.5 index + U feedback.&quot;&quot;&quot;</span>
    <span class="n">chosen_arm</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandTopM_UCB_Utilde"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RandTopM_UCB_Utilde">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RandTopM_UCB_Utilde</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RandTopM policy + UCB_0.5 index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="n">chosen_arm</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandTopM_UCB_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RandTopM_UCB_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RandTopM_UCB_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RandTopM policy + UCB_0.5 index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="n">chosen_arm</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandTopM_KLUCB_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RandTopM_KLUCB_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RandTopM_KLUCB_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RandTopM policy + Bernoulli KL-UCB index + U feedback.&quot;&quot;&quot;</span>
    <span class="n">chosen_arm</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandTopM_KLUCB_Utilde"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RandTopM_KLUCB_Utilde">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RandTopM_KLUCB_Utilde</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RandTopM policy + Bernoulli KL-UCB index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="n">chosen_arm</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandTopM_KLUCB_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RandTopM_KLUCB_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RandTopM_KLUCB_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RandTopM policy + Bernoulli KL-UCB index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="n">chosen_arm</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">((</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="RandTopM_RandomNewChosenArm"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.RandTopM_RandomNewChosenArm">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">RandTopM_RandomNewChosenArm</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">collision</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RandTopM chooses a new arm after a collision or if the chosen arm lies outside of its estimatedBestArms set, uniformly from the set of estimated M best arms, or keep the same.&quot;&quot;&quot;</span>
    <span class="n">player</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">players</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">player</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="n">collision</span><span class="p">)</span> <span class="k">if</span> <span class="n">player</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="k">else</span> <span class="n">player</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span></div>

<span class="c1"># default_policy, default_update_memory = RandTopM_UCB_U, RandTopM_RandomNewChosenArm</span>



<span class="c1"># --- MCTopM variants</span>

<div class="viewcode-block" id="write_to_tuple"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.write_to_tuple">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">write_to_tuple</span><span class="p">(</span><span class="n">this_tuple</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tuple cannot be written, this hack fixes that.&quot;&quot;&quot;</span>
    <span class="n">this_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">this_tuple</span><span class="p">)</span>
    <span class="n">this_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">this_list</span><span class="p">)</span></div>

<div class="viewcode-block" id="MCTopM_UCB_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.MCTopM_UCB_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">MCTopM_UCB_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MCTopM policy + UCB_0.5 index + U feedback.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># if no sitted information yet</span>
        <span class="n">state</span><span class="o">.</span><span class="n">memories</span> <span class="o">=</span> <span class="n">write_to_tuple</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="n">chosen_arm</span><span class="p">,</span> <span class="n">sitted</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="MCTopM_UCB_Utilde"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.MCTopM_UCB_Utilde">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">MCTopM_UCB_Utilde</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MCTopM policy + UCB_0.5 index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># if no sitted information yet</span>
        <span class="n">state</span><span class="o">.</span><span class="n">memories</span> <span class="o">=</span> <span class="n">write_to_tuple</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="n">chosen_arm</span><span class="p">,</span> <span class="n">sitted</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="MCTopM_UCB_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.MCTopM_UCB_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">MCTopM_UCB_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MCTopM policy + UCB_0.5 index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># if no sitted information yet</span>
        <span class="n">state</span><span class="o">.</span><span class="n">memories</span> <span class="o">=</span> <span class="n">write_to_tuple</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="n">chosen_arm</span><span class="p">,</span> <span class="n">sitted</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="MCTopM_KLUCB_U"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.MCTopM_KLUCB_U">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">MCTopM_KLUCB_U</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MCTopM policy + Bernoulli KL-UCB index + U feedback.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># if no sitted information yet</span>
        <span class="n">state</span><span class="o">.</span><span class="n">memories</span> <span class="o">=</span> <span class="n">write_to_tuple</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="n">chosen_arm</span><span class="p">,</span> <span class="n">sitted</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="MCTopM_KLUCB_Utilde"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.MCTopM_KLUCB_Utilde">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">MCTopM_KLUCB_Utilde</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MCTopM policy + Bernoulli KL-UCB index + Utilde feedback.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># if no sitted information yet</span>
        <span class="n">state</span><span class="o">.</span><span class="n">memories</span> <span class="o">=</span> <span class="n">write_to_tuple</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="n">chosen_arm</span><span class="p">,</span> <span class="n">sitted</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="MCTopM_KLUCB_Ubar"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.MCTopM_KLUCB_Ubar">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">MCTopM_KLUCB_Ubar</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;MCTopM policy + Bernoulli KL-UCB index + Ubar feedback.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># if no sitted information yet</span>
        <span class="n">state</span><span class="o">.</span><span class="n">memories</span> <span class="o">=</span> <span class="n">write_to_tuple</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="n">chosen_arm</span><span class="p">,</span> <span class="n">sitted</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">indexes</span> <span class="o">=</span> <span class="n">klucb</span><span class="p">((</span><span class="n">state</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
    <span class="n">indexes</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">+</span><span class="n">oo</span>
    <span class="n">estimatedBestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">indexes</span><span class="p">)[</span><span class="o">-</span><span class="n">state</span><span class="o">.</span><span class="n">M</span><span class="p">:]</span>
    <span class="k">if</span> <span class="n">collision</span> <span class="ow">or</span> <span class="n">chosen_arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">estimatedBestArms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">estimatedBestArms</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chosen_arm</span><span class="p">]</span></div>

<div class="viewcode-block" id="MCTopM_RandomNewChosenArm"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.MCTopM_RandomNewChosenArm">[docs]</a><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">MCTopM_RandomNewChosenArm</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">decision</span><span class="p">,</span> <span class="n">collision</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RandTopMC chooses a new arm after if the chosen arm lies outside of its estimatedBestArms set, uniformly from the set of estimated M best arms, or keep the same.&quot;&quot;&quot;</span>
    <span class="n">player</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">players</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="n">chosen_arm</span><span class="p">,</span> <span class="n">sitted</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">memories</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sitted</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">collision</span><span class="p">:</span>  <span class="c1"># new arm from estimatedBestArms</span>
            <span class="n">chosen_arms</span> <span class="o">=</span> <span class="n">player</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">collision</span><span class="o">=</span><span class="n">collision</span><span class="p">)</span> <span class="k">if</span> <span class="n">player</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="k">else</span> <span class="n">player</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">chosen_arms</span><span class="p">,</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">chosen_arms</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># sitted, for now</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">decision</span><span class="p">,</span> <span class="kc">True</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># sitted but the chair changed ==&gt; not sitted</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">chosen_arm</span><span class="p">,</span> <span class="n">chosen_arm</span> <span class="o">==</span> <span class="n">decision</span><span class="p">)]</span></div>

<span class="c1"># default_policy, default_update_memory = MCTopM_UCB_U, MCTopM_RandomNewChosenArm</span>


<span class="c1"># --- Generate vector of formal means mu_1,...,mu_K</span>

<div class="viewcode-block" id="symbol_means"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.symbol_means">[docs]</a><span class="k">def</span> <span class="nf">symbol_means</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Better to work directly with symbols and instantiate the results *after*.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sympy</span><span class="o">.</span><span class="n">var</span><span class="p">([</span><span class="s1">&#39;mu_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span></div>

<div class="viewcode-block" id="random_uniform_means"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.random_uniform_means">[docs]</a><span class="k">def</span> <span class="nf">random_uniform_means</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If needed, generate an array of K (numerical) uniform means in [0, 1].&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">K</span><span class="p">)</span></div>


<div class="viewcode-block" id="uniform_means"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.uniform_means">[docs]</a><span class="k">def</span> <span class="nf">uniform_means</span><span class="p">(</span><span class="n">nbArms</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a list of means of arms, well spaced:</span>

<span class="sd">    - in [lower, lower + amplitude],</span>
<span class="sd">    - sorted in increasing order,</span>
<span class="sd">    - starting from lower + amplitude * delta, up to lower + amplitude * (1 - delta),</span>
<span class="sd">    - and there is nbArms arms.</span>

<span class="sd">    &gt;&gt;&gt; np.array(uniform_means(2, 0.1))</span>
<span class="sd">    array([ 0.1,  0.9])</span>
<span class="sd">    &gt;&gt;&gt; np.array(uniform_means(3, 0.1))</span>
<span class="sd">    array([ 0.1,  0.5,  0.9])</span>
<span class="sd">    &gt;&gt;&gt; np.array(uniform_means(9, 1 / (1. + 9)))</span>
<span class="sd">    array([ 0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">nbArms</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Error: &#39;nbArms&#39; = </span><span class="si">{}</span><span class="s2"> has to be &gt;= 1.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbArms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
    <span class="k">assert</span> <span class="n">amplitude</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error: &#39;amplitude&#39; = </span><span class="si">{:.3g}</span><span class="s2"> has to be &gt; 0.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">amplitude</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
    <span class="k">assert</span> <span class="mf">0.</span> <span class="o">&lt;</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="s2">&quot;Error: &#39;delta&#39; = </span><span class="si">{:.3g}</span><span class="s2"> has to be in (0, 1).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
    <span class="n">mus</span> <span class="o">=</span> <span class="n">lower</span> <span class="o">+</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">nbArms</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mus</span><span class="p">))</span></div>

<span class="c1"># --- Transform probabilities to float, expr, str</span>

<div class="viewcode-block" id="proba2float"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.proba2float">[docs]</a><span class="k">def</span> <span class="nf">proba2float</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Replace mu_k by a numerical value and evaluation  the formula.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="s2">&quot;evalf&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">K</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">uniform_means</span><span class="p">(</span><span class="n">nbArms</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">symbol_means</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">proba</span><span class="o">.</span><span class="n">evalf</span><span class="p">(</span><span class="n">subs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">values</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">proba</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># a bit of str rewriting</span>
        <span class="k">return</span> <span class="n">proba</span></div>

<div class="viewcode-block" id="simplify"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.simplify">[docs]</a><span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="n">proba</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Try to simplify the expression of the probability.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="s2">&quot;simplify&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">proba</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span><span class="o">.</span><span class="n">factor</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">proba</span></div>

<div class="viewcode-block" id="proba2str"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.proba2str">[docs]</a><span class="k">def</span> <span class="nf">proba2str</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">html_in_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Pretty print a proba, either a number, a Fraction, or a sympy expression.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">str_proba</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:.3g}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">proba</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">Fraction</span><span class="p">):</span>
        <span class="n">str_proba</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">proba</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># a bit of str rewriting</span>
        <span class="n">str_proba</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">proba</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*\*([0-9]+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;^{\1}&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">html_in_var_names</span><span class="p">:</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\*\*([0-9]+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;&lt;SUP&gt;\1&lt;/SUP&gt;&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">str_proba</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">,</span> <span class="s1">&#39;^&#39;</span><span class="p">)</span>
        <span class="n">str_proba</span> <span class="o">=</span> <span class="n">str_proba</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\(mu_([0-9]+) - 1\)\(mu_([0-9]+) - 1\)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;(1-mu_\1)(1-mu_\2)&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
        <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;-mu_([0-9]+) \+ 1&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;1-mu_\1&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
        <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;-(.*)\(mu_([0-9]+) - 1\)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1(1-mu_\2)&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
        <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;-\(mu_([0-9]+) - 1\)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;(1-mu_\1)&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>  <span class="c1"># replace mu_12 by mu_{12}</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;_([0-9]+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;_{\1}&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;mu_&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\mu_&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">str_proba</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">str_proba</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\\\</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">html_in_var_names</span><span class="p">:</span>  <span class="c1"># replace mu_12 by mu&lt;sub&gt;12&lt;/sub&gt;</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;_([0-9]+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;&lt;SUB&gt;\1&lt;/SUB&gt;&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># to avoid dealing with unicode for Python2...</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;mu_&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">str_proba</span> <span class="o">=</span> <span class="n">re_sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;mu_&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;Âµ&#39;</span><span class="p">,</span> <span class="n">str_proba</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">str_proba</span></div>


<span class="c1"># --- Transform .tex to .pdf</span>

<div class="viewcode-block" id="tex2pdf"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.tex2pdf">[docs]</a><span class="k">def</span> <span class="nf">tex2pdf</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Naive call to command line pdflatex, twice.&quot;&quot;&quot;</span>
    <span class="n">dir1</span> <span class="o">=</span> <span class="n">getcwd</span><span class="p">()</span>
    <span class="n">dir2</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="n">dirname</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now compiling it to PDF with &#39;pdflatex </span><span class="si">{}</span><span class="s2"> &amp;&amp; pdflatex </span><span class="si">{}</span><span class="s2">&#39; ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">base</span><span class="p">))</span>
    <span class="n">log</span><span class="p">,</span> <span class="n">gz</span><span class="p">,</span> <span class="n">aux</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.tex&#39;</span><span class="p">,</span> <span class="s1">&#39;.log&#39;</span><span class="p">),</span> <span class="n">base</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.tex&#39;</span><span class="p">,</span> <span class="s1">&#39;.synctex.gz&#39;</span><span class="p">),</span> <span class="n">base</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.tex&#39;</span><span class="p">,</span> <span class="s1">&#39;.aux&#39;</span><span class="p">)</span>
    <span class="n">chdir</span><span class="p">(</span><span class="n">dir2</span><span class="p">)</span>  <span class="c1"># go in the plots/trees/ subdir</span>
    <span class="k">if</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s2">&quot;pdflatex&quot;</span><span class="p">,</span> <span class="s2">&quot;-halt-on-error&quot;</span><span class="p">,</span> <span class="n">base</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/dev/null&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s2">&quot;pdflatex&quot;</span><span class="p">,</span> <span class="s2">&quot;-halt-on-error&quot;</span><span class="p">,</span> <span class="n">base</span><span class="p">],</span> <span class="n">stdout</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;/dev/null&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">))</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s2">&quot;mv&quot;</span><span class="p">,</span> <span class="s2">&quot;-f&quot;</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">gz</span><span class="p">,</span> <span class="n">aux</span><span class="p">,</span> <span class="s2">&quot;/tmp/&quot;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s2">&quot;pdflatex&quot;</span><span class="p">,</span> <span class="s2">&quot;-halt-on-error&quot;</span><span class="p">,</span> <span class="n">base</span><span class="p">])</span>
    <span class="n">chdir</span><span class="p">(</span><span class="n">dir1</span><span class="p">)</span>  <span class="c1"># go back</span></div>

<span class="c1"># --- Data representation&#39;</span>

<div class="viewcode-block" id="State"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State">[docs]</a><span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Not space-efficient representation of a state in the system we model.</span>

<span class="sd">    - S, Stilde, N, Ntilde: are arrays of size (M, K),</span>
<span class="sd">    - depth, t, M, K: integers, to avoid recomputing them,</span>
<span class="sd">    - mus: the problem parameters (only for Bernoulli arms),</span>
<span class="sd">    - players: is a list of algorithms,</span>
<span class="sd">    - probas: list of transition probabilities,</span>
<span class="sd">    - children: list of all possible next states (transitions).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="State.__init__"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Stilde</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Ntilde</span><span class="p">,</span> <span class="n">mus</span><span class="p">,</span> <span class="n">players</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new state. Arrays S, Stilde, N, Ntilde are *copied* to avoid modify previous values!&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>  <span class="c1">#: sensing feedback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Stilde</span><span class="p">)</span>  <span class="c1">#: number of sensing trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>  <span class="c1">#: number of succesful transmissions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Ntilde</span><span class="p">)</span>  <span class="c1">#: number of trials without collisions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mus</span> <span class="o">=</span> <span class="n">mus</span>  <span class="c1"># XXX OK memory efficient: only a pointer to the (never modified) list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">players</span> <span class="o">=</span> <span class="n">players</span>  <span class="c1"># XXX OK memory efficient: only a pointer to the (never modified) list</span>
        <span class="c1"># New arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>  <span class="c1">#: current depth of the exploration tree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1">#: current time step. Simply = sum(N[0]) = sum(N[i]) for all player i, but easier to compute it once and store it</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Stilde</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Ntilde</span><span class="p">),</span> <span class="s2">&quot;Error: difference in shapes of S, Stilde, N, Ntilde.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>  <span class="c1">#: number of players</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">players</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="s2">&quot;Error: &#39;players&#39; list is not of size M ...&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>  <span class="c1">#: number of arms (channels)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">mus</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="s2">&quot;Error: &#39;mus&#39; list is not of size K ...&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: list of next state, representing all the possible transitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probas</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: probabilities of transitions</span></div>

    <span class="c1"># --- Utility</span>

<div class="viewcode-block" id="State.__str__"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">concise</span><span class="o">=</span><span class="n">CONCISE</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">concise</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;    State : M = </span><span class="si">{}</span><span class="s2">, K = </span><span class="si">{}</span><span class="s2"> and t = </span><span class="si">{}</span><span class="s2">, depth = </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: Stilde</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: N</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;    State : M = </span><span class="si">{}</span><span class="s2">, K = </span><span class="si">{}</span><span class="s2"> and t = </span><span class="si">{}</span><span class="s2">, depth = </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: S</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: Stilde</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: N</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: Ntilde</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">)</span></div>

<div class="viewcode-block" id="State.to_node"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.to_node">[docs]</a>    <span class="k">def</span> <span class="nf">to_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">concise</span><span class="o">=</span><span class="n">CONCISE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the state as a small string to be attached to a GraphViz node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">concise</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;[[&quot;</span> <span class="o">+</span> <span class="s2">&quot;], [&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.3g}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">st</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span> <span class="k">for</span> <span class="n">st2</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;]]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;[[&quot;</span> <span class="o">+</span> <span class="s2">&quot;], [&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.3g}</span><span class="s2">:</span><span class="si">{:.3g}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">nt2</span><span class="p">))</span> <span class="k">for</span> <span class="n">s2</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">nt2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;]]&quot;</span></div>

<div class="viewcode-block" id="State.to_dot"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.to_dot">[docs]</a>    <span class="k">def</span> <span class="nf">to_dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
               <span class="n">latex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">html_in_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">,</span>
               <span class="n">onlyleafs</span><span class="o">=</span><span class="n">ONLYLEAFS</span><span class="p">,</span> <span class="n">onlyabsorbing</span><span class="o">=</span><span class="n">ONLYABSORBING</span><span class="p">,</span> <span class="n">concise</span><span class="o">=</span><span class="n">CONCISE</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert the state to a .dot graph, using GraphViz. See http://graphviz.readthedocs.io/ for more details.</span>

<span class="sd">        - onlyleafs: only print the root and the leafs, to see a concise representation of the tree.</span>
<span class="sd">        - onlyabsorbing: only print the absorbing leafs, to see a really concise representation of the tree.</span>
<span class="sd">        - concise: weather to use the short representation of states (using :math:`\tilde{S}` and :math:`N`) or the long one (using the 4 variables).</span>
<span class="sd">        - html_in_var_names: experimental use of ``&lt;SUB&gt;..&lt;/SUB&gt;`` and ``&lt;SUP&gt;..&lt;/SUP&gt;`` in the label for the tree.</span>
<span class="sd">        - latex: experimental use of ``_{..}`` and ``^{..}`` in the label for the tree, to use with dot2tex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="n">Digraph</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Creating a dot graph from the tree...&quot;</span><span class="p">)</span>
        <span class="n">dot</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">overlap</span><span class="o">=</span><span class="s2">&quot;false&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">title</span><span class="p">:</span> <span class="n">dot</span><span class="o">.</span><span class="n">attr</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">wraptext</span><span class="p">(</span><span class="n">title</span><span class="p">))</span>
        <span class="n">node_number</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">onlyleafs</span><span class="p">:</span>
            <span class="n">root_name</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="bp">self</span>
            <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">to_node</span><span class="p">(</span><span class="n">concise</span><span class="o">=</span><span class="n">concise</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
            <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">get_unique_leafs</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">leafs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Useless to save a tree with more than 256 leafs, the resulting image will be too large to be viewed.&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
            <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span><span class="p">):</span>
                <span class="c1"># add a UNIQUE identifier for each node: easy, just do a breath-first search, and use numbers from 0 to big-integer-that-is-computed on the fly</span>
                <span class="n">node_number</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">leaf_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_number</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">():</span>
                    <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">leaf_name</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">to_node</span><span class="p">(</span><span class="n">concise</span><span class="o">=</span><span class="n">concise</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
                    <span class="n">dot</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">leaf_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">proba2str</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="n">latex</span><span class="p">,</span> <span class="n">html_in_var_names</span><span class="o">=</span><span class="n">html_in_var_names</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;black&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">onlyabsorbing</span><span class="p">:</span>
                    <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">leaf_name</span><span class="p">,</span> <span class="n">leaf</span><span class="o">.</span><span class="n">to_node</span><span class="p">(</span><span class="n">concise</span><span class="o">=</span><span class="n">concise</span><span class="p">))</span>
                    <span class="n">dot</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">leaf_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">proba2str</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="n">latex</span><span class="p">,</span> <span class="n">html_in_var_names</span><span class="o">=</span><span class="n">html_in_var_names</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;black&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_explore</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)])</span>  <span class="c1"># BFS using a deque, DFS using a list/recursive call</span>
            <span class="n">nb_node</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># convert each state to a node and a list of edge</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_explore</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nb_node</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">root_name</span><span class="p">,</span> <span class="n">root</span> <span class="o">=</span> <span class="n">to_explore</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">root_name</span> <span class="o">==</span> <span class="s2">&quot;0&quot;</span><span class="p">:</span>
                    <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">to_node</span><span class="p">(</span><span class="n">concise</span><span class="o">=</span><span class="n">concise</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">root</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">():</span>
                    <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">to_node</span><span class="p">(</span><span class="n">concise</span><span class="o">=</span><span class="n">concise</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">onlyabsorbing</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">has_absorbing_child_whole_subtree</span><span class="p">():</span>
                        <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">to_node</span><span class="p">(</span><span class="n">concise</span><span class="o">=</span><span class="n">concise</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dot</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">to_node</span><span class="p">(</span><span class="n">concise</span><span class="o">=</span><span class="n">concise</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">probas</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
                    <span class="c1"># add a UNIQUE identifier for each node: easy, just do a breath-first search, and use numbers from 0 to big-integer-that-is-computed on the fly</span>
                    <span class="n">node_number</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">child_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_number</span><span class="p">)</span>
                    <span class="c1"># here, if onlyabsorbing, I should only print the *paths* leading to absorbing leafs!</span>
                    <span class="k">if</span> <span class="n">onlyabsorbing</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">has_absorbing_child_whole_subtree</span><span class="p">():</span>
                            <span class="n">dot</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">proba2str</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="n">latex</span><span class="p">,</span> <span class="n">html_in_var_names</span><span class="o">=</span><span class="n">html_in_var_names</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;black&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dot</span><span class="o">.</span><span class="n">edge</span><span class="p">(</span><span class="n">root_name</span><span class="p">,</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">proba2str</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="n">latex</span><span class="p">,</span> <span class="n">html_in_var_names</span><span class="o">=</span><span class="n">html_in_var_names</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span> <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">()</span> <span class="k">else</span> <span class="s2">&quot;black&quot;</span><span class="p">)</span>
                    <span class="n">to_explore</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child_name</span><span class="p">,</span> <span class="n">child</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">nb_node</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Useless to save a tree with more than 1024 nodes, the resulting image will be too large to be viewed.&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="k">return</span> <span class="n">dot</span></div>

<div class="viewcode-block" id="State.saveto"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.saveto">[docs]</a>    <span class="k">def</span> <span class="nf">saveto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
               <span class="n">latex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">html_in_var_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">FORMAT</span><span class="p">,</span>
               <span class="n">onlyleafs</span><span class="o">=</span><span class="n">ONLYLEAFS</span><span class="p">,</span> <span class="n">onlyabsorbing</span><span class="o">=</span><span class="n">ONLYABSORBING</span><span class="p">,</span> <span class="n">concise</span><span class="o">=</span><span class="n">CONCISE</span><span class="p">):</span>
        <span class="c1"># Hack to fix the LaTeX output</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">title</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dot</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span>
                          <span class="n">html_in_var_names</span><span class="o">=</span><span class="n">html_in_var_names</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="n">latex</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">,</span>
                          <span class="n">onlyleafs</span><span class="o">=</span><span class="n">onlyleafs</span><span class="p">,</span> <span class="n">onlyabsorbing</span><span class="o">=</span><span class="n">onlyabsorbing</span><span class="p">,</span> <span class="n">concise</span><span class="o">=</span><span class="n">concise</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">latex</span><span class="p">:</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">dot</span><span class="o">.</span><span class="n">source</span>
            <span class="k">if</span> <span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="n">source</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s1">&#39;utf_8&#39;</span><span class="p">)</span>
            <span class="c1"># print(&quot;source =\n&quot;, source)  # DEBUG</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.gv&#39;</span><span class="p">,</span> <span class="s1">&#39;.gv.tex&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving the dot graph to &#39;</span><span class="si">{}</span><span class="s2">&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">dot2tex</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;tikz&#39;</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figonly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">texmode</span><span class="o">=</span><span class="s1">&#39;raw&#39;</span><span class="p">))</span>
            <span class="n">tex2pdf</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.gv.tex&#39;</span><span class="p">,</span> <span class="s1">&#39;__onlyfig.gv.tex&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving the dot graph to &#39;</span><span class="si">{}</span><span class="s2">&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">dot2tex</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;tikz&#39;</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">figonly</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">texmode</span><span class="o">=</span><span class="s1">&#39;raw&#39;</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Saving the dot graph to &#39;</span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2">&#39;...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ext</span><span class="p">))</span>
            <span class="n">dot</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="n">view</span><span class="p">)</span></div>
        <span class="c1"># done for saving the graph</span>

<div class="viewcode-block" id="State.copy"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a new copy of that state with same S, Stilde, N, Ntilde but no probas and no children (and depth=0).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">State</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="n">Stilde</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Ntilde</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">,</span> <span class="n">players</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">)</span></div>

<div class="viewcode-block" id="State.__hash__"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.__hash__">[docs]</a>    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">FULLHASH</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hash the matrix Stilde and N of the state.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span></div>

<div class="viewcode-block" id="State.is_absorbing"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.is_absorbing">[docs]</a>    <span class="k">def</span> <span class="nf">is_absorbing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to detect if this state is absorbing, ie only one transition is possible, and again infinitely for the only child.</span>

<span class="sd">        .. warning:: Still very experimental!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME still not sure about the characterization of absorbing states</span>
        <span class="c1"># if at least two players have the same S, Stilde, N, Ntilde lines</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">j1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">]</span>
                <span class="n">are_all_equal</span> <span class="o">=</span> <span class="p">[</span> <span class="n">tupleit1</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j1</span><span class="p">])</span> <span class="o">==</span> <span class="n">tupleit1</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j2</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span> <span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">are_all_equal</span><span class="p">):</span>
                    <span class="c1"># bad_line = add([tupleit1(a[j1]) for a in A])</span>
                    <span class="c1"># bad_line = tupleit1(self.S[j1])</span>
                    <span class="n">bad_line</span> <span class="o">=</span> <span class="n">tupleit1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j1</span><span class="p">])</span>
                    <span class="c1"># and if that line has only different values</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bad_line</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_line</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="State.has_absorbing_child_whole_subtree"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.has_absorbing_child_whole_subtree">[docs]</a>    <span class="k">def</span> <span class="nf">has_absorbing_child_whole_subtree</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to detect if this state has an absorbing child in the whole subtree. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">has_absorbing_child_whole_subtree</span><span class="p">()</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span></div>

    <span class="c1"># --- High level view of a depth-1 exploration</span>

<div class="viewcode-block" id="State.explore_from_node_to_depth"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.explore_from_node_to_depth">[docs]</a>    <span class="k">def</span> <span class="nf">explore_from_node_to_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute recursively the one_depth children of the root and its children.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">For depth = </span><span class="si">{}</span><span class="s2">, exploring from this node :</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_one_depth</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="n">child</span><span class="o">.</span><span class="n">explore_from_node_to_depth</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="State.compute_one_depth"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.compute_one_depth">[docs]</a>    <span class="k">def</span> <span class="nf">compute_one_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use all_deltas to store all the possible transitions and their probabilities. Increase depth by 1 at the end.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">uniq_children</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">uniq_probas</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">delta</span><span class="p">,</span> <span class="n">proba</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_deltas</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">proba</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c1"># copy the current state, apply decision of algorithms and random branching</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">delta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>  <span class="c1"># I guess I could use states directly as key, but this would cost more in terms of memory</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">uniq_children</span><span class="p">:</span>
                <span class="n">uniq_probas</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="n">proba</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">child</span><span class="o">.</span><span class="n">depth</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">uniq_children</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span>
                <span class="n">uniq_probas</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">proba</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   at depth </span><span class="si">{}</span><span class="s2"> we saw </span><span class="si">{}</span><span class="s2"> different unique children states...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_children</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probas</span> <span class="o">=</span> <span class="p">[</span><span class="n">simplify</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">uniq_probas</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq_children</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>
        <span class="c1"># Done for computing all the children and probability of transitions</span>

<div class="viewcode-block" id="State.all_absorbing_states"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.all_absorbing_states">[docs]</a>    <span class="k">def</span> <span class="nf">all_absorbing_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator that yields all the absorbing nodes of the tree, one by one.</span>

<span class="sd">        - It might not find any,</span>
<span class="sd">        - It does so without merging common nodes, in order to find the first absorbing node as quick as possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">bad_child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">absorbing_states_one_depth</span><span class="p">():</span>
            <span class="c1"># print(&quot;all_absorbing_states: yielding proba, child = {}, \n{}&quot;.format(proba, bad_child))  # DEBUG</span>
            <span class="k">yield</span> <span class="n">proba</span><span class="p">,</span> <span class="n">bad_child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compute_one_depth</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">bad_child</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">all_absorbing_states</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># print(&quot;all_absorbing_states: yielding proba, child = {}, \n{}&quot;.format(proba, bad_child))  # DEBUG</span>
                    <span class="k">yield</span> <span class="n">proba</span><span class="p">,</span> <span class="n">bad_child</span></div>

<div class="viewcode-block" id="State.absorbing_states_one_depth"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.absorbing_states_one_depth">[docs]</a>    <span class="k">def</span> <span class="nf">absorbing_states_one_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Use all_deltas to yield all the absorbing one-depth child and their probabilities.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">delta</span><span class="p">,</span> <span class="n">proba</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_deltas</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">proba</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c1"># copy the current state, apply decision of algorithms and random branching</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">delta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">():</span>
                <span class="c1"># print(&quot;absorbing_states_one_depth: yielding proba, child = {}, \n{}&quot;.format(proba, child))  # DEBUG</span>
                <span class="k">yield</span> <span class="n">proba</span><span class="p">,</span> <span class="n">child</span></div>

<div class="viewcode-block" id="State.find_N_absorbing_states"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.find_N_absorbing_states">[docs]</a>    <span class="k">def</span> <span class="nf">find_N_absorbing_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxdepth</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find at least N absorbing states, by considering a large depth.&quot;&quot;&quot;</span>
        <span class="n">complete_probas</span><span class="p">,</span> <span class="n">bad_children</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">bad_child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_absorbing_states</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">maxdepth</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">bad_child</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">(),</span> <span class="s2">&quot;Error: a node was returned by all_absorbing_states() method but was not absorbing!&quot;</span>
            <span class="n">complete_probas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">proba</span><span class="p">)</span>
            <span class="n">bad_children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bad_child</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_children</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">complete_probas</span><span class="p">,</span> <span class="n">bad_children</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Impossible to find N = </span><span class="si">{}</span><span class="s2"> absorbing states from this root (max depth = </span><span class="si">{}</span><span class="s2">)...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">))</span></div>

    <span class="c1"># --- The hard part is this all_deltas *generator*</span>

<div class="viewcode-block" id="State.all_deltas"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.all_deltas">[docs]</a>    <span class="k">def</span> <span class="nf">all_deltas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator that yields functions transforming state to another state.</span>

<span class="sd">        - It is memory efficient as it is a generator.</span>
<span class="sd">        - Do not convert that to a list or it might use all your system memory: each returned value is a function with code and variables inside!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_decisions</span> <span class="o">=</span> <span class="p">[</span> <span class="n">player</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">player</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">number_of_decisions</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">decisions</span><span class="p">)</span> <span class="k">for</span> <span class="n">decisions</span> <span class="ow">in</span> <span class="n">all_decisions</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">decisions</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">all_decisions</span><span class="p">):</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">decisions</span><span class="p">)</span>
            <span class="n">collisions</span> <span class="o">=</span> <span class="p">[</span><span class="n">counter</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">coin_flips</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                <span class="n">proba_of_this_coin_flip</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">mu</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coin_flips</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">))</span>
                <span class="c1"># Create a function to apply this transition</span>
                <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">s</span><span class="o">.</span><span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">Ij</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decisions</span><span class="p">):</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">Ij</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coin_flips</span><span class="p">[</span><span class="n">Ij</span><span class="p">]</span>  <span class="c1"># sensing feedback</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">Ij</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># number of sensing trials</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">collisions</span><span class="p">[</span><span class="n">Ij</span><span class="p">]:</span>  <span class="c1"># no collision, receive this feedback for rewards</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">Ij</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coin_flips</span><span class="p">[</span><span class="n">Ij</span><span class="p">]</span>  <span class="c1"># number of succesful transmissions</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">Ij</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># number of trials without collisions</span>
                    <span class="k">return</span> <span class="n">s</span>
                <span class="c1"># Compute the probability of this transition</span>
                <span class="n">proba</span> <span class="o">=</span> <span class="n">proba_of_this_coin_flip</span> <span class="o">/</span> <span class="n">number_of_decisions</span>
                <span class="k">if</span> <span class="n">proba</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">proba</span><span class="p">)</span></div>

    <span class="c1"># --- Main functions, all explorations are depth first search (not the best, it&#39;s just easier...)</span>

<div class="viewcode-block" id="State.pretty_print_result_recursively"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.pretty_print_result_recursively">[docs]</a>    <span class="k">def</span> <span class="nf">pretty_print_result_recursively</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print all the transitions, depth by depth (recursively).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X &quot;</span><span class="o">*</span><span class="mi">87</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The state:</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="s2">seems to be absorbing...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X &quot;</span><span class="o">*</span><span class="mi">87</span><span class="p">)</span>
            <span class="c1"># return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">From this state :</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">- Probability of transition = </span><span class="si">{}</span><span class="s2"> to this other state:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">child</span><span class="p">))</span>
                <span class="n">child</span><span class="o">.</span><span class="n">pretty_print_result_recursively</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==&gt; Done for the </span><span class="si">{}</span><span class="s2"> children of this state...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)))</span></div>

<div class="viewcode-block" id="State.get_all_leafs"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.get_all_leafs">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_leafs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recurse and get all the leafs. Many different state can be present in the list of leafs, with possibly different probabilities (each correspond to a trajectory).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">probas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="c1"># assert len(self.probas) &gt; 0</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
                <span class="c1"># assert child.depth == (self.depth - 1)</span>
                <span class="n">c</span><span class="p">,</span> <span class="n">l</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">get_all_leafs</span><span class="p">()</span>
                <span class="c1"># assert all([s.depth == 0 for s in l])</span>
                <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">proba</span> <span class="o">*</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>  <span class="c1"># one more step, multiply but a proba</span>
                <span class="n">complete_probas</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">leafs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span></div>

<div class="viewcode-block" id="State.get_unique_leafs"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.get_unique_leafs">[docs]</a>    <span class="k">def</span> <span class="nf">get_unique_leafs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute all the leafs (deepest children) and merge the common one to compute their full probabilities.&quot;&quot;&quot;</span>
        <span class="n">uniq_complete_probas</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">uniq_leafs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_leafs</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span><span class="p">):</span>
            <span class="n">h</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">uniq_leafs</span><span class="p">:</span>
                <span class="n">uniq_complete_probas</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">+=</span> <span class="n">proba</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">uniq_complete_probas</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">proba</span>
                <span class="n">uniq_leafs</span><span class="p">[</span><span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">simplify</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">uniq_complete_probas</span><span class="o">.</span><span class="n">values</span><span class="p">()],</span> <span class="nb">list</span><span class="p">(</span><span class="n">uniq_leafs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span></div>

<div class="viewcode-block" id="State.proba_reaching_absorbing_state"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.State.proba_reaching_absorbing_state">[docs]</a>    <span class="k">def</span> <span class="nf">proba_reaching_absorbing_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the probability of reaching a leaf that is an absorbing state.&quot;&quot;&quot;</span>
        <span class="n">probas</span><span class="p">,</span> <span class="n">leafs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unique_leafs</span><span class="p">()</span>
        <span class="n">bad_proba</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nb_absorbing</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">probas</span><span class="p">,</span> <span class="n">leafs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">():</span>
                <span class="n">bad_proba</span> <span class="o">+=</span> <span class="n">proba</span>
                <span class="n">nb_absorbing</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">For depth </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2"> leafs were found to be absorbing, and the probability of reaching any absorbing leaf is </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">nb_absorbing</span><span class="p">,</span> <span class="n">bad_proba</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
        <span class="n">sample_values</span> <span class="o">=</span> <span class="n">uniform_means</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">==&gt; Numerically, for means = </span><span class="si">{}</span><span class="s2">, this probability is = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_values</span><span class="p">),</span> <span class="n">proba2float</span><span class="p">(</span><span class="n">bad_proba</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">sample_values</span><span class="p">)))</span>  <span class="c1"># DEBUG</span>
        <span class="k">return</span> <span class="n">nb_absorbing</span><span class="p">,</span> <span class="n">bad_proba</span></div></div>


<div class="viewcode-block" id="StateWithMemory"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.StateWithMemory">[docs]</a><span class="k">class</span> <span class="nc">StateWithMemory</span><span class="p">(</span><span class="n">State</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;State with a memory for each player, to represent and play with RhoRand etc.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="StateWithMemory.__init__"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.StateWithMemory.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Stilde</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Ntilde</span><span class="p">,</span> <span class="n">mus</span><span class="p">,</span> <span class="n">players</span><span class="p">,</span> <span class="n">update_memories</span><span class="p">,</span> <span class="n">memories</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StateWithMemory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Stilde</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">Ntilde</span><span class="p">,</span> <span class="n">mus</span><span class="p">,</span> <span class="n">players</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_memories</span> <span class="o">=</span> <span class="n">update_memories</span>
        <span class="k">if</span> <span class="n">memories</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memories</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memories</span> <span class="o">=</span> <span class="n">memories</span>  <span class="c1">#: Personal memory for all players, can be a rank in {1,..,M} for rhoRand, or anything else.</span></div>

<div class="viewcode-block" id="StateWithMemory.__str__"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.StateWithMemory.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">concise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">concise</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;    StateWithMemory : M = </span><span class="si">{}</span><span class="s2">, K = </span><span class="si">{}</span><span class="s2"> and t = </span><span class="si">{}</span><span class="s2">, depth = </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: Stilde</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: N</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: players memory</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memories</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;    StateWithMemory : M = </span><span class="si">{}</span><span class="s2">, K = </span><span class="si">{}</span><span class="s2"> and t = </span><span class="si">{}</span><span class="s2">, depth = </span><span class="si">{}</span><span class="s2">.</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: S</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: Stilde</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: N</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: Ntilde</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =: players memory</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memories</span><span class="p">)</span></div>

<div class="viewcode-block" id="StateWithMemory.to_node"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.StateWithMemory.to_node">[docs]</a>    <span class="k">def</span> <span class="nf">to_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">concise</span><span class="o">=</span><span class="n">CONCISE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Print the state as a small string to be attached to a GraphViz node.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">concise</span><span class="p">:</span>
            <span class="c1"># return &quot;[[&quot; + &quot;], [&quot;.join(&quot;,&quot;.join(&quot;{:.3g}/{}&quot;.format(st, n) for st, n in zip(st2, n2)) for st2, n2 in zip(self.S, self.N)) + &quot;]]&quot; + &quot; r={}&quot;.format(list(self.memories))  # if U is used instead of Utilde</span>
            <span class="k">return</span> <span class="s2">&quot;[[&quot;</span> <span class="o">+</span> <span class="s2">&quot;], [&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.3g}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">st</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">st2</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span> <span class="k">for</span> <span class="n">st2</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;]]&quot;</span> <span class="o">+</span> <span class="s2">&quot; r=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memories</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;[[&quot;</span> <span class="o">+</span> <span class="s2">&quot;], [&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:.3g}</span><span class="s2">:</span><span class="si">{:.3g}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nt</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">st</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">nt2</span><span class="p">))</span> <span class="k">for</span> <span class="n">s2</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">nt2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;]]&quot;</span> <span class="o">+</span> <span class="s2">&quot; ranks = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memories</span><span class="p">)</span></div>

<div class="viewcode-block" id="StateWithMemory.copy"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.StateWithMemory.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a new copy of that state with same S, Stilde, N, Ntilde but no probas and no children (and depth=0).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">StateWithMemory</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="n">Stilde</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="n">Ntilde</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">,</span> <span class="n">players</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">,</span> <span class="n">update_memories</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">update_memories</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">memories</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memories</span><span class="p">)</span></div>

<div class="viewcode-block" id="StateWithMemory.__hash__"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.StateWithMemory.__hash__">[docs]</a>    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="n">FULLHASH</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Hash the matrix Stilde and N of the state and memories of the players (ie. ranks for RhoRand).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">full</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memories</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># return hash(tupleit2(self.S) + tupleit2(self.N) + tupleit1(self.memories))  # if U is used instead of Utilde</span>
            <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Stilde</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))</span> <span class="o">+</span> <span class="nb">hash</span><span class="p">(</span><span class="n">tupleit1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memories</span><span class="p">))</span></div>

<div class="viewcode-block" id="StateWithMemory.is_absorbing"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.StateWithMemory.is_absorbing">[docs]</a>    <span class="k">def</span> <span class="nf">is_absorbing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Try to detect if this state is absorbing, ie only one transition is possible, and again infinitely for the only child.</span>

<span class="sd">        .. warning:: Still very experimental!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;random&#39;</span> <span class="ow">in</span> <span class="n">update_memory</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">update_memory</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_memories</span><span class="p">):</span>
            <span class="c1"># eg RandomNewRank gives True, ConstantRank gives False</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">StateWithMemory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">()</span></div>

<div class="viewcode-block" id="StateWithMemory.all_deltas"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.StateWithMemory.all_deltas">[docs]</a>    <span class="k">def</span> <span class="nf">all_deltas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator that yields functions transforming state to another state.</span>

<span class="sd">        - It is memory efficient as it is a generator.</span>
<span class="sd">        - Do not convert that to a list or it might use all your system memory: each returned value is a function with code and variables inside!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_decisions</span> <span class="o">=</span> <span class="p">[</span> <span class="n">player</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">player</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">players</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">number_of_decisions</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">decisions</span><span class="p">)</span> <span class="k">for</span> <span class="n">decisions</span> <span class="ow">in</span> <span class="n">all_decisions</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">decisions</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">all_decisions</span><span class="p">):</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">decisions</span><span class="p">)</span>
            <span class="n">collisions</span> <span class="o">=</span> <span class="p">[</span><span class="n">counter</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
            <span class="n">all_memories</span> <span class="o">=</span> <span class="p">[</span> <span class="n">update_memory</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">decisions</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">collisions</span><span class="p">[</span><span class="n">decisions</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">update_memory</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_memories</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">number_of_memories</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">memories</span><span class="p">)</span> <span class="k">for</span> <span class="n">memories</span> <span class="ow">in</span> <span class="n">all_memories</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">memories</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">all_memories</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">coin_flips</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">):</span>
                    <span class="n">proba_of_this_coin_flip</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">mu</span> <span class="k">if</span> <span class="n">b</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coin_flips</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mus</span><span class="p">))</span>
                    <span class="c1"># Create a function to apply this transition</span>
                    <span class="k">def</span> <span class="nf">delta</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">memories</span> <span class="o">=</span> <span class="n">memories</span>  <span class="c1"># Erase internal ranks etc</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">t</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">s</span><span class="o">.</span><span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">Ij</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">decisions</span><span class="p">):</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">Ij</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coin_flips</span><span class="p">[</span><span class="n">Ij</span><span class="p">]</span>  <span class="c1"># sensing feedback</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">Ij</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># number of sensing trials</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">collisions</span><span class="p">[</span><span class="n">Ij</span><span class="p">]:</span>  <span class="c1"># no collision, receive this feedback for rewards</span>
                                <span class="n">s</span><span class="o">.</span><span class="n">Stilde</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">Ij</span><span class="p">]</span> <span class="o">+=</span> <span class="n">coin_flips</span><span class="p">[</span><span class="n">Ij</span><span class="p">]</span>  <span class="c1"># number of succesful transmissions</span>
                                <span class="n">s</span><span class="o">.</span><span class="n">Ntilde</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">Ij</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># number of trials without collisions</span>
                        <span class="k">return</span> <span class="n">s</span>
                    <span class="c1"># Compute the probability of this transition</span>
                    <span class="n">proba</span> <span class="o">=</span> <span class="n">proba_of_this_coin_flip</span> <span class="o">/</span> <span class="p">(</span><span class="n">number_of_decisions</span> <span class="o">*</span> <span class="n">number_of_memories</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">proba</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">proba</span><span class="p">)</span></div></div>


<span class="c1"># --- Main function</span>

<div class="viewcode-block" id="main"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">players</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_memories</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Stilde</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ntilde</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">find_only_N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute all the transitions, and print them.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
        <span class="n">K</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">mus</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mus</span> <span class="o">=</span> <span class="n">symbol_means</span><span class="p">(</span><span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mus</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">players</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">players</span> <span class="o">=</span> <span class="p">[</span><span class="n">default_policy</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span>
    <span class="c1"># if update_memories is None:</span>
    <span class="c1">#     update_memories = [default_update_memory for _ in range(M)]</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">players</span><span class="p">)</span>
    <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="n">K</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">,</span> <span class="s2">&quot;Error: only 1 &lt;= M &lt;= K &lt;= 10 are supported... and M = </span><span class="si">{}</span><span class="s2">, K = </span><span class="si">{}</span><span class="s2"> here...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>  <span class="c1"># XXX it is probably impossible to have a code managing larger values...</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">,</span> <span class="s2">&quot;Error: only 0 &lt;= depth &lt;= 20 is supported... and depth = </span><span class="si">{}</span><span class="s2"> here...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>  <span class="c1"># XXX it is probably impossible to have a code managing larger values...</span>
    <span class="c1"># Compute starting state</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Use only integers, to speed up in this case of Bernoulli arms. XXX in the general case it is not true!</span>
    <span class="k">if</span> <span class="n">Stilde</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Stilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># Use only integers, to speed up in this case of Bernoulli arms. XXX in the general case it is not true!</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Ntilde</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Ntilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span>  <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Create the root state</span>
    <span class="k">if</span> <span class="n">update_memories</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">StateWithMemory</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">Stilde</span><span class="o">=</span><span class="n">Stilde</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">Ntilde</span><span class="o">=</span><span class="n">Ntilde</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="n">mus</span><span class="p">,</span> <span class="n">players</span><span class="o">=</span><span class="n">players</span><span class="p">,</span> <span class="n">update_memories</span><span class="o">=</span><span class="n">update_memories</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">State</span><span class="p">(</span><span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">Stilde</span><span class="o">=</span><span class="n">Stilde</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">Ntilde</span><span class="o">=</span><span class="n">Ntilde</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="n">mus</span><span class="p">,</span> <span class="n">players</span><span class="o">=</span><span class="n">players</span><span class="p">)</span>
    <span class="c1"># Should we only look for find_only_N absorbing child?</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Starting to explore transitions up-to depth </span><span class="si">{}</span><span class="s2"> for this root state:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Using these policies:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">playerId</span><span class="p">,</span> <span class="n">player</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">players</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Player #</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> uses </span><span class="si">{}</span><span class="s2"> (which is </span><span class="si">{}</span><span class="s2">)...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">playerId</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">player</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">player</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">update_memories</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Using these update_memories:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">playerId</span><span class="p">,</span> <span class="n">update_memory</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">update_memories</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Player #</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> uses </span><span class="si">{}</span><span class="s2"> (which is </span><span class="si">{}</span><span class="s2">)...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">playerId</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">update_memory</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">update_memory</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Using these arms:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">muId</span><span class="p">,</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mus</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Arm #</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> has mean </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">muId</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">find_only_N</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find_N_absorbing_states</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">find_only_N</span><span class="p">,</span> <span class="n">maxdepth</span><span class="o">=</span><span class="n">depth</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2">As asked, we found </span><span class="si">{}</span><span class="s2"> absorbing nodes or leafs from this root at max depth = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">find_only_N</span><span class="p">,</span> <span class="n">depth</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">bad_child</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;At depth </span><span class="si">{}</span><span class="s2">, this node was found to be absorbing with probability </span><span class="si">{}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bad_child</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">proba</span><span class="p">,</span> <span class="n">bad_child</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Explore from the root</span>
        <span class="n">root</span><span class="o">.</span><span class="n">explore_from_node_to_depth</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">)</span>
        <span class="c1"># Print everything</span>
        <span class="c1"># root.pretty_print_result_recursively()</span>
        <span class="c1"># Get all leafs</span>
        <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">get_unique_leafs</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n\n</span><span class="s2">There are </span><span class="si">{}</span><span class="s2"> unique leafs for depth </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leafs</span><span class="p">),</span> <span class="n">depth</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">proba</span><span class="p">,</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Leaf with probability = </span><span class="si">{}</span><span class="s2">:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">proba</span><span class="p">,</span> <span class="n">leaf</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">leaf</span><span class="o">.</span><span class="n">is_absorbing</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  At depth </span><span class="si">{}</span><span class="s2">, this leaf was found to be absorbing !&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">))</span>
    <span class="c1"># Done</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Done for exploring transitions up-to depth </span><span class="si">{}</span><span class="s2"> for this root state:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">root</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Using these policies:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">playerId</span><span class="p">,</span> <span class="n">player</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">players</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Player #</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> uses </span><span class="si">{}</span><span class="s2"> (which is </span><span class="si">{}</span><span class="s2">)...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">playerId</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">player</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">player</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">update_memories</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Using these update_memories:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">playerId</span><span class="p">,</span> <span class="n">update_memory</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">update_memories</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Player #</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> uses </span><span class="si">{}</span><span class="s2"> (which is </span><span class="si">{}</span><span class="s2">)...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">playerId</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">update_memory</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">update_memory</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Using these arms:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">muId</span><span class="p">,</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mus</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - Arm #</span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2"> has mean </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">muId</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">find_only_N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">There were </span><span class="si">{}</span><span class="s2"> unique leafs for depth </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">leafs</span><span class="p">),</span> <span class="n">depth</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">,</span> <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span></div>


<span class="c1"># --- Main script</span>

<div class="viewcode-block" id="test"><a class="viewcode-back" href="../docs/complete_tree_exploration_for_MP_bandits.html#complete_tree_exploration_for_MP_bandits.test">[docs]</a><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Stilde</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ntilde</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">all_players</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">all_update_memories</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">find_only_N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test the main exploration function for various all_players.&quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">all_players</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_players</span> <span class="o">=</span> <span class="p">[</span><span class="n">FixedArm</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">all_update_memories</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_update_memories</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_players</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">policy</span><span class="p">,</span> <span class="n">update_memory</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_players</span><span class="p">,</span> <span class="n">all_update_memories</span><span class="p">):</span>
        <span class="n">players</span> <span class="o">=</span> <span class="p">[</span> <span class="n">policy</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">update_memories</span> <span class="o">=</span> <span class="p">[</span> <span class="n">update_memory</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="p">]</span> <span class="k">if</span> <span class="n">update_memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># get the result</span>
        <span class="n">root</span><span class="p">,</span> <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span> <span class="o">=</span> <span class="n">main</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">players</span><span class="o">=</span><span class="n">players</span><span class="p">,</span> <span class="n">update_memories</span><span class="o">=</span><span class="n">update_memories</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">Stilde</span><span class="o">=</span><span class="n">Stilde</span><span class="p">,</span> <span class="n">Ntilde</span><span class="o">=</span><span class="n">Ntilde</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="n">mus</span><span class="p">,</span> <span class="n">find_only_N</span><span class="o">=</span><span class="n">find_only_N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">find_only_N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># computing absorbing states</span>
            <span class="n">nb_absorbing</span><span class="p">,</span> <span class="n">bad_proba</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">proba_reaching_absorbing_state</span><span class="p">()</span>
            <span class="c1"># XXX save the graph and maybe display it, in different versions</span>
            <span class="k">for</span> <span class="n">onlyabsorbing</span><span class="p">,</span> <span class="n">onlyleafs</span> <span class="ow">in</span> <span class="n">product</span><span class="p">((</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">nb_absorbing</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">onlyabsorbing</span><span class="p">:</span>  <span class="k">continue</span>
                <span class="k">if</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">onlyleafs</span><span class="p">:</span>  <span class="k">continue</span>
                <span class="k">for</span> <span class="n">latex</span><span class="p">,</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">((</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;svg&#39;</span><span class="p">),</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s1">&#39;svg&#39;</span><span class="p">)):</span>  <span class="c1"># , (False, &#39;png&#39;)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;Tree_exploration_K=</span><span class="si">{}</span><span class="s2">_M=</span><span class="si">{}</span><span class="s2">_depth=</span><span class="si">{}</span><span class="s2">__</span><span class="si">{}{}{}{}</span><span class="s2">.gv&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">K</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">policy</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                    <span class="s2">&quot;__</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">update_memory</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="k">if</span> <span class="n">update_memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                                    <span class="s2">&quot;__absorbing&quot;</span> <span class="k">if</span> <span class="n">onlyabsorbing</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                                    <span class="s2">&quot;__leafs&quot;</span> <span class="k">if</span> <span class="n">onlyleafs</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                        <span class="p">)</span>
                        <span class="n">root</span><span class="o">.</span><span class="n">saveto</span><span class="p">(</span><span class="n">os_path_join</span><span class="p">(</span><span class="n">PLOT_DIR</span><span class="p">,</span> <span class="n">filename</span><span class="p">),</span> <span class="n">view</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span>
                                    <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Tree exploration for K=</span><span class="si">{}</span><span class="s2"> arms and M=</span><span class="si">{}</span><span class="s2"> players using </span><span class="si">{}{}</span><span class="s2">, for depth=</span><span class="si">{}</span><span class="s2"> : </span><span class="si">{}</span><span class="s2"> leafs, </span><span class="si">{}</span><span class="s2"> absorbing&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">policy</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                                      <span class="s2">&quot; and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">update_memory</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span> <span class="k">if</span> <span class="n">update_memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                                                      <span class="n">depth</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">leafs</span><span class="p">),</span> <span class="n">nb_absorbing</span><span class="p">),</span>
                                    <span class="n">onlyabsorbing</span><span class="o">=</span><span class="n">onlyabsorbing</span><span class="p">,</span> <span class="n">onlyleafs</span><span class="o">=</span><span class="n">onlyleafs</span><span class="p">,</span>
                                    <span class="n">latex</span><span class="o">=</span><span class="n">latex</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="n">ext</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    Error when saving:&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nb_absorbing</span><span class="p">,</span> <span class="n">bad_proba</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">complete_probas</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">complete_probas</span><span class="p">)</span>
        <span class="c1"># store everything</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">root</span><span class="p">,</span> <span class="n">complete_probas</span><span class="p">,</span> <span class="n">leafs</span><span class="p">,</span> <span class="n">nb_absorbing</span><span class="p">,</span> <span class="n">bad_proba</span><span class="p">])</span>
        <span class="c1"># ask for Enter to continue</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">[Enter] to continue...&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">results</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">all_update_memories</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">all_players</span> <span class="o">=</span> <span class="p">[</span><span class="n">FixedArm</span><span class="p">]</span>  <span class="c1"># XXX just for testing</span>
    <span class="n">all_players</span> <span class="o">=</span> <span class="p">[</span><span class="n">UniformExploration</span><span class="p">]</span>  <span class="c1"># XXX just for testing</span>

    <span class="c1"># --- XXX Test for Selfish Utilde</span>
    <span class="c1"># all_update_memories = [ConstantRank]</span>
    <span class="n">all_players</span> <span class="o">=</span> <span class="p">[</span><span class="n">Selfish_0Greedy_Utilde</span><span class="p">,</span> <span class="n">Selfish_UCB_Utilde</span><span class="p">,</span> <span class="n">Selfish_KLUCB_Utilde</span><span class="p">]</span>  <span class="c1"># XXX complete comparison</span>
    <span class="c1"># all_players = [Selfish_UCB_Utilde, Selfish_KLUCB_Utilde]  # XXX comparison</span>

    <span class="n">all_players</span> <span class="o">=</span> <span class="p">[</span><span class="n">Selfish_UCB</span><span class="p">,</span> <span class="n">Selfish_KLUCB</span><span class="p">]</span>  <span class="c1"># XXX comparison</span>
    <span class="c1"># all_players = [Selfish_KLUCB_Utilde]</span>
    <span class="c1"># all_players = [Selfish_UCB_Utilde]  # Faster, and probably same error cases as KLUCB</span>

    <span class="c1"># # --- XXX Test for RhoRand</span>
    <span class="c1"># all_players = [RhoRand_UCB_Utilde, RhoRand_KLUCB_Utilde]  # XXX  comparison</span>
    <span class="c1"># all_players = [RhoRand_KLUCB_U]</span>
    <span class="c1"># all_players = [RhoRand_UCB_U]  # Faster, and probably same error cases as KLUCB</span>
    <span class="c1"># all_update_memories = [RandomNewRank]</span>

    <span class="c1"># # --- XXX Test for RandTopM</span>
    <span class="c1"># all_players = [RandTopM_UCB_U]  # Faster, and probably same error cases as KLUCB</span>
    <span class="c1"># all_update_memories = [RandTopM_RandomNewChosenArm]</span>

    <span class="c1"># # --- XXX Test for RandTopMC</span>
    <span class="c1"># all_players = [MCTopM_UCB_U]  # Faster, and probably same error cases as KLUCB</span>
    <span class="c1"># all_update_memories = [MCTopM_RandomNewChosenArm]</span>

    <span class="c1"># --- XXX Faster or symbolic computations?</span>
    <span class="n">mus</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># use mu_1, .., mu_K as symbols, by default</span>
    <span class="c1"># mus = [0, 1]</span>
    <span class="c1"># mus = [0.1, 0.9]</span>
    <span class="c1"># mus = [0.1, 0.5, 0.9]</span>

    <span class="c1"># --- XXX Read parameters from the cli env</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;DEPTH&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">))</span>
    <span class="n">M</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">))</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">))</span>
    <span class="n">DEBUG</span> <span class="o">=</span> <span class="n">mybool</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;DEBUG&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>

    <span class="n">find_only_N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;FIND_ONLY_N&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">find_only_N</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="n">find_only_N</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">find_only_N</span><span class="p">:</span>
        <span class="n">mus</span> <span class="o">=</span> <span class="n">uniform_means</span><span class="p">(</span><span class="n">nbArms</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">mus</span><span class="o">=</span><span class="n">mus</span><span class="p">,</span> <span class="n">all_players</span><span class="o">=</span><span class="n">all_players</span><span class="p">,</span> <span class="n">all_update_memories</span><span class="o">=</span><span class="n">all_update_memories</span><span class="p">,</span> <span class="n">find_only_N</span><span class="o">=</span><span class="n">find_only_N</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">DEBUG</span><span class="p">)</span>

    <span class="c1"># # XXX default start state</span>
    <span class="c1"># M, K = 1, 1</span>
    <span class="c1"># for depth in [8]:</span>
    <span class="c1">#     print(&quot;For depth = {} ...&quot;.format(depth))</span>
    <span class="c1">#     results = test(depth=depth, M=M, K=K, mus=mus, all_players=all_players, all_update_memories=all_update_memories, find_only_N=find_only_N, debug=DEBUG)</span>

    <span class="c1"># # XXX default start state</span>
    <span class="c1"># M, K = 2, 2</span>
    <span class="c1"># # mus = [0.8, 0.2]</span>
    <span class="c1"># # mus = [Fraction(4, 5), Fraction(1, 5)]</span>
    <span class="c1"># for depth in [1, 2, 3]:</span>
    <span class="c1">#     print(&quot;For depth = {} ...&quot;.format(depth))</span>
    <span class="c1">#     results = test(depth=depth, M=M, K=K, mus=mus, all_players=all_players, all_update_memories=all_update_memories, find_only_N=find_only_N, debug=DEBUG)</span>

    <span class="c1"># # XXX What if we start from an absorbing state?</span>
    <span class="c1"># M, K = 2, 2</span>
    <span class="c1"># S = np.array([[1, 0], [1, 0]])</span>
    <span class="c1"># Stilde = np.array([[1, 0], [1, 0]])</span>
    <span class="c1"># N = np.array([[2, 1], [2, 1]])</span>
    <span class="c1"># Ntilde = np.array([[2, 1], [2, 1]])</span>
    <span class="c1"># for depth in [1, 2, 3]:</span>
    <span class="c1">#     results = test(depth=depth, M=M, K=K, S=S, Stilde=Stilde, N=N, Ntilde=Ntilde, mus=mus, all_players=all_players, all_update_memories=all_update_memories, find_only_N=find_only_N, debug=DEBUG)</span>

    <span class="c1"># # XXX default start state</span>
    <span class="c1"># M, K = 2, 3</span>
    <span class="c1"># results = test(depth=depth, M=M, K=K, mus=mus, all_players=all_players, all_update_memories=all_update_memories, find_only_N=find_only_N, debug=DEBUG)</span>

    <span class="c1"># XXX What if we start from an absorbing state?</span>
    <span class="c1"># M, K = 2, 3</span>
    <span class="c1"># S = np.array([[2, 1, 0], [2, 1, 0]])</span>
    <span class="c1"># Stilde = np.array([[2, 1, 0], [2, 1, 0]])</span>
    <span class="c1"># N = np.array([[4, 3, 1], [4, 3, 1]])</span>
    <span class="c1"># Ntilde = np.array([[4, 3, 1], [4, 3, 1]])</span>
    <span class="c1"># # for depth in [1]:</span>
    <span class="c1"># for depth in [2, 3, 4]:</span>
    <span class="c1">#     # results = test(depth=depth, M=M, K=K, mus=mus, all_players=all_players, all_update_memories=all_update_memories, find_only_N=find_only_N, debug=DEBUG)</span>
    <span class="c1">#     results = test(depth=depth, M=M, K=K, S=S, Stilde=Stilde, N=N, Ntilde=Ntilde, mus=mus, all_players=all_players, all_update_memories=all_update_memories, find_only_N=find_only_N, debug=DEBUG)</span>

    <span class="c1"># M, K = 3, 3</span>
    <span class="c1"># results = test(depth=depth, M=M, K=K, mus=mus, all_players=all_players, all_update_memories=all_update_memories, find_only_N=find_only_N, debug=DEBUG)</span>

<span class="c1"># End of complete_tree_exploration_for_MP_bandits.py</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2018, Lilian Besson (Naereen)
      <span class="lastupdated">
        Last updated on 13 Jun 2019, 09h.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>