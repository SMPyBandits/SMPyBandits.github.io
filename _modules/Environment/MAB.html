

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-38514290-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Environment.MAB &mdash; SMPyBandits 0.9.5 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> SMPyBandits
          

          
            
            <img src="../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.9
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html"><em>SMPyBandits</em></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs/modules.html">SMPyBandits modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../How_to_run_the_code.html">How to run the code ?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../PublicationsWithSMPyBandits.html">List of research publications using Lilian Bessonâ€™s SMPyBandits project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Aggregation.html"><strong>Policy aggregation algorithms</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MultiPlayers.html"><strong>Multi-players simulation environment</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../DoublingTrick.html"><strong>Doubling Trick for Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../SparseBandits.html"><strong>Structure and Sparsity of Stochastic Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NonStationaryBandits.html"><strong>Non-Stationary Stochastic Multi-Armed Bandits</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../API.html">Short documentation of the API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../TODO.html">ðŸ’¥ TODO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../plots/README.html">Some illustrations for this project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/README.html">Jupyter Notebooks ðŸ““ by Naereen &#64; GitHub</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/list.html">List of notebooks for SMPyBandits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Profiling.html">A note on execution times, speed and profiling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../uml_diagrams/README.html">UML diagrams</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../logs/README.html"><code class="docutils literal notranslate"><span class="pre">logs</span></code> files</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SMPyBandits</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>Environment.MAB</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for Environment.MAB</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot; :class:`MAB`, :class:`MarkovianMAB`, :class:`ChangingAtEachRepMAB`, :class:`IncreasingMAB`, :class:`PieceWiseStationaryMAB` and :class:`NonStationaryMAB` classes to wrap the arms of some Multi-Armed Bandit problems.</span>

<span class="sd">Such class has to have *at least* these methods:</span>

<span class="sd">- ``draw(armId, t)`` to draw *one* sample from that ``armId`` at time ``t``,</span>
<span class="sd">- and ``reprarms()`` to pretty print the arms (for titles of a plot),</span>
<span class="sd">- and more, see below.</span>

<span class="sd">.. warning:: FIXME it is still a work in progress, I need to add continuously varying environments. See https://github.com/SMPyBandits/SMPyBandits/issues/71</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>  <span class="c1"># Python 2 compatibility</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Lilian Besson&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.9&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.pykov</span> <span class="k">import</span> <span class="n">Chain</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pykov</span> <span class="k">import</span> <span class="n">Chain</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: &#39;pykov&#39; module seems to not be available. But it is shipped with SMPyBandits. Weird.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dou you want to try to install it from https://github.com/riccardoscalco/Pykov ?&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: the &#39;MarkovianMAB&#39; class will not work...&quot;</span><span class="p">)</span>

<span class="c1"># Local imports</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.plotsettings</span> <span class="k">import</span> <span class="n">signature</span><span class="p">,</span> <span class="n">wraptext</span><span class="p">,</span> <span class="n">wraplatex</span><span class="p">,</span> <span class="n">palette</span><span class="p">,</span> <span class="n">makemarkers</span><span class="p">,</span> <span class="n">legend</span><span class="p">,</span> <span class="n">show_and_save</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">plotsettings</span> <span class="k">import</span> <span class="n">signature</span><span class="p">,</span> <span class="n">wraptext</span><span class="p">,</span> <span class="n">wraplatex</span><span class="p">,</span> <span class="n">palette</span><span class="p">,</span> <span class="n">makemarkers</span><span class="p">,</span> <span class="n">legend</span><span class="p">,</span> <span class="n">show_and_save</span>


<div class="viewcode-block" id="MAB"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB">[docs]</a><span class="k">class</span> <span class="nc">MAB</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Basic Multi-Armed Bandit problem, for stochastic and i.i.d. arms.</span>

<span class="sd">    - configuration can be a dict with &#39;arm_type&#39; and &#39;params&#39; keys. &#39;arm_type&#39; is a class from the Arms module, and &#39;params&#39; is a dict, used as a list/tuple/iterable of named parameters given to &#39;arm_type&#39;. Example::</span>

<span class="sd">        configuration = {</span>
<span class="sd">            &#39;arm_type&#39;: Bernoulli,</span>
<span class="sd">            &#39;params&#39;:   [0.1, 0.5, 0.9]</span>
<span class="sd">        }</span>

<span class="sd">        configuration = {  # for fixed variance Gaussian</span>
<span class="sd">            &#39;arm_type&#39;: Gaussian,</span>
<span class="sd">            &#39;params&#39;:   [0.1, 0.5, 0.9]</span>
<span class="sd">        }</span>

<span class="sd">    - But it can also accept a list of already created arms::</span>

<span class="sd">        configuration = [</span>
<span class="sd">            Bernoulli(0.1),</span>
<span class="sd">            Bernoulli(0.5),</span>
<span class="sd">            Bernoulli(0.9),</span>
<span class="sd">        ]</span>

<span class="sd">    - Both will create three Bernoulli arms, of parameters (means) 0.1, 0.5 and 0.9.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MAB.__init__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;New MAB.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Creating a new MAB problem ...&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isChangingAtEachRepetition</span>   <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: Flag to know if the problem is changing at each repetition or not.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isDynamic</span>   <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: Flag to know if the problem is static or not.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isMarkovian</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: Flag to know if the problem is Markovian or not.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arms</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#: List of arms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Reading arms of this MAB problem from a dictionnary &#39;configuration&#39; = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">configuration</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
            <span class="n">arm_type</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;arm_type&quot;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;arm_type&#39; =&quot;</span><span class="p">,</span> <span class="n">arm_type</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;params&#39; =&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
            <span class="c1"># Each &#39;param&#39; could be one value (eg. &#39;mean&#39; = probability for a Bernoulli) or a tuple (eg. &#39;(mu, sigma)&#39; for a Gaussian) or a dictionnary</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arm_type</span><span class="p">(</span><span class="o">*</span><span class="n">param</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="k">else</span> <span class="n">arm_type</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
            <span class="c1"># XXX try to read sparsity</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;sparsity&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;sparsity&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Taking arms of this MAB problem from a list of arms &#39;configuration&#39; = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">configuration</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
            <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arm</span><span class="p">)</span>

        <span class="c1"># Compute the means and stats</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;arms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">arm</span><span class="o">.</span><span class="n">mean</span> <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">])</span>  <span class="c1">#: Means of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;means&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>  <span class="c1">#: Number of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;nbArms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;sparsity&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1">#: Max mean of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;maxArm&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1">#: Min mean of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;minArm&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="c1"># Print lower bound and HOI factor</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">This MAB problem has: </span><span class="se">\n</span><span class="s2"> - a [Lai &amp; Robbins] complexity constant C(mu) = </span><span class="si">{:.3g}</span><span class="s2"> ... </span><span class="se">\n</span><span class="s2"> - a Optimal Arm Identification factor H_OI(mu) = </span><span class="si">{:.2%}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowerbound</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">hoifactor</span><span class="p">()))</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;arms&#39; represented as:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reprarms</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># DEBUG</span></div>

<div class="viewcode-block" id="MAB.new_order_of_arm"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.new_order_of_arm">[docs]</a>    <span class="k">def</span> <span class="nf">new_order_of_arm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Feed a new order of the arms to the environment.</span>

<span class="sd">        - Updates :attr:`means` correctly.</span>
<span class="sd">        - Return the new position(s) of the best arm (to count and plot ``BestArmPulls`` correctly).</span>

<span class="sd">        .. warning:: This is a very limited support of non-stationary environment: only permutations of the arms are allowed, see :class:`NonStationaryMAB` for more.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">arm</span><span class="o">.</span><span class="n">mean</span> <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">])</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">arm</span><span class="o">.</span><span class="n">mean</span> <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="n">arms</span><span class="p">]),</span> <span class="s2">&quot;Error: the new list of arms = </span><span class="si">{}</span><span class="s2"> does not have the same means as the previous ones.&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">arms</span><span class="p">),</span> <span class="s2">&quot;Error: the new list of arms = </span><span class="si">{}</span><span class="s2"> does not have the same means as the previous ones.&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arms</span> <span class="o">=</span> <span class="n">arms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">arm</span><span class="o">.</span><span class="n">mean</span> <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="MAB.__repr__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(nbArms: </span><span class="si">{}</span><span class="s2">, arms: </span><span class="si">{}</span><span class="s2">, minArm: </span><span class="si">{:.3g}</span><span class="s2">, maxArm: </span><span class="si">{:.3g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">)</span></div>

<div class="viewcode-block" id="MAB.reprarms"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.reprarms">[docs]</a>    <span class="k">def</span> <span class="nf">reprarms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">openTag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">endTag</span><span class="o">=</span><span class="s1">&#39;^*&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a str representation of the list of the arms (like `repr(self.arms)` but better)</span>

<span class="sd">        - If nbPlayers &gt; 0, it surrounds the representation of the best arms by openTag, endTag (for plot titles, in a multi-player setting).</span>

<span class="sd">        - Example: openTag = &#39;&#39;, endTag = &#39;^*&#39; for LaTeX tags to put a star exponent.</span>
<span class="sd">        - Example: openTag = &#39;&lt;red&gt;&#39;, endTag = &#39;&lt;/red&gt;&#39; for HTML-like tags.</span>
<span class="sd">        - Example: openTag = r&#39;\textcolor{red}{&#39;, endTag = &#39;}&#39; for LaTeX tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nbPlayers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">nbPlayers</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error, the &#39;nbPlayers&#39; argument for reprarms method of a MAB object has to be a non-negative integer.&quot;</span>  <span class="c1"># DEBUG</span>
            <span class="n">append_to_repr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="n">means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span>
            <span class="n">bestmean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
            <span class="n">bestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">means</span><span class="p">)[</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">):]</span>
            <span class="n">repr_arms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">arm</span><span class="p">)</span> <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">]</span>

            <span class="c1"># WARNING improve display for Gaussian arms that all have same variance</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="s2">&quot;Gaussian&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arm</span><span class="p">))</span> <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">({</span><span class="n">arm</span><span class="o">.</span><span class="n">sigma</span> <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sigma</span>
                <span class="n">repr_arms</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;, </span><span class="si">{:.3g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sigma</span><span class="p">),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">repr_arms</span><span class="p">]</span>
                <span class="n">append_to_repr</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;, \sigma^2=</span><span class="si">{:.3g}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="k">if</span> <span class="n">latex</span> <span class="k">else</span> <span class="s2">&quot;, sigma2=</span><span class="si">{:.3g}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nbPlayers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">bestArms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">text</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">openTag</span> <span class="o">+</span> <span class="n">repr_arms</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span> <span class="o">+</span> <span class="n">endTag</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nbPlayers</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">armId</span> <span class="ow">in</span> <span class="n">bestArms</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">arm</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">bestmean</span><span class="p">)))</span>
                <span class="k">else</span> <span class="n">repr_arms</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">armId</span><span class="p">,</span> <span class="n">arm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="n">text</span> <span class="o">+=</span> <span class="n">append_to_repr</span>
        <span class="k">return</span> <span class="n">wraplatex</span><span class="p">(</span><span class="s1">&#39;$&#39;</span> <span class="o">+</span> <span class="n">text</span> <span class="o">+</span> <span class="s1">&#39;$&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">latex</span> <span class="k">else</span> <span class="n">wraptext</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>

    <span class="c1"># --- Draw samples</span>

<div class="viewcode-block" id="MAB.draw"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">armId</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a random sample from the armId-th arm, at time t. Usually t is not used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">t</span><span class="p">)</span></div>

<div class="viewcode-block" id="MAB.draw_nparray"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.draw_nparray">[docs]</a>    <span class="k">def</span> <span class="nf">draw_nparray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">armId</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)):</span>
        <span class="sd">&quot;&quot;&quot; Return a numpy array of random sample from the armId-th arm, of a certain shape.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span><span class="o">.</span><span class="n">draw_nparray</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="MAB.draw_each"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.draw_each">[docs]</a>    <span class="k">def</span> <span class="nf">draw_each</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a random sample from each arm, at time t. Usually t is not used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">armId</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">armId</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)])</span></div>

<div class="viewcode-block" id="MAB.draw_each_nparray"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.draw_each_nparray">[docs]</a>    <span class="k">def</span> <span class="nf">draw_each_nparray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,)):</span>
        <span class="sd">&quot;&quot;&quot; Return a numpy array of random sample from each arm, of a certain shape.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">draw_nparray</span><span class="p">(</span><span class="n">armId</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">armId</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)])</span></div>

    <span class="c1">#</span>
    <span class="c1"># --- Helper to compute sets Mbest and Mworst</span>

<div class="viewcode-block" id="MAB.Mbest"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.Mbest">[docs]</a>    <span class="k">def</span> <span class="nf">Mbest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set of M best means.&quot;&quot;&quot;</span>
        <span class="n">sortedMeans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sortedMeans</span><span class="p">[</span><span class="o">-</span><span class="n">M</span><span class="p">:]</span></div>

<div class="viewcode-block" id="MAB.Mworst"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.Mworst">[docs]</a>    <span class="k">def</span> <span class="nf">Mworst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set of M worst means.&quot;&quot;&quot;</span>
        <span class="n">sortedMeans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sortedMeans</span><span class="p">[:</span><span class="o">-</span><span class="n">M</span><span class="p">]</span></div>

<div class="viewcode-block" id="MAB.sumBestMeans"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.sumBestMeans">[docs]</a>    <span class="k">def</span> <span class="nf">sumBestMeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Sum of the M best means.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Mbest</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">))</span></div>

    <span class="c1">#</span>
    <span class="c1"># --- Helper to compute vector of min arms, max arms, all arms</span>

<div class="viewcode-block" id="MAB.get_minArm"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.get_minArm">[docs]</a>    <span class="k">def</span> <span class="nf">get_minArm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vector of min mean of the arms.</span>

<span class="sd">        - It is a vector of length horizon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">horizon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span><span class="p">)</span></div>
        <span class="c1"># return self.minArm  # XXX Nope, it&#39;s not a constant!</span>

<div class="viewcode-block" id="MAB.get_maxArm"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.get_maxArm">[docs]</a>    <span class="k">def</span> <span class="nf">get_maxArm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vector of max mean of the arms.</span>

<span class="sd">        - It is a vector of length horizon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">horizon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">)</span></div>
        <span class="c1"># return self.maxArm  # XXX Nope, it&#39;s not a constant!</span>

<div class="viewcode-block" id="MAB.get_allMeans"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.get_allMeans">[docs]</a>    <span class="k">def</span> <span class="nf">get_allMeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vector of means of the arms.</span>

<span class="sd">        - It is a numpy array of shape (nbArms, horizon).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># allMeans = np.tile(self.means, (horizon, 1)).T</span>
        <span class="n">allMeans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">horizon</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">horizon</span><span class="p">):</span>
            <span class="n">allMeans</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span>
        <span class="k">return</span> <span class="n">allMeans</span></div>

    <span class="c1">#</span>
    <span class="c1"># --- Estimate sparsity</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Estimate the sparsity of the problem, i.e., the number of arms with positive means.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="MAB.str_sparsity"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.str_sparsity">[docs]</a>    <span class="k">def</span> <span class="nf">str_sparsity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Empty string if ``sparsity = nbArms``, or a small string &#39;, $s={}$&#39; if the sparsity is strictly less than the number of arm.&quot;&quot;&quot;</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparsity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">,</span> <span class="s2">&quot;Error: sparsity s = </span><span class="si">{}</span><span class="s2"> has to be 0 &lt;= s &lt;= K = </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
        <span class="c1"># WARNING</span>
        <span class="c1"># disable this feature when not working on sparse simulations</span>
        <span class="c1"># return &quot;&quot;</span>
        <span class="c1"># or bring back this feature when working on sparse simulations</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">K</span> <span class="k">else</span> <span class="s2">&quot;, $s=</span><span class="si">{}</span><span class="s2">$&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># --- Compute lower bounds</span>

<div class="viewcode-block" id="MAB.lowerbound"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.lowerbound">[docs]</a>    <span class="k">def</span> <span class="nf">lowerbound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute the constant :math:`C(\mu)`, for the [Lai &amp; Robbins] lower-bound for this MAB problem (complexity), using functions from ``kullback.py`` or ``kullback.so`` (see :mod:`Arms.kullback`). &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">oneLR</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">)</span></div>

<div class="viewcode-block" id="MAB.lowerbound_sparse"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.lowerbound_sparse">[docs]</a>    <span class="k">def</span> <span class="nf">lowerbound_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sparsity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the constant :math:`C(\mu)`, for [Kwon et al, 2017] lower-bound for sparse bandits for this MAB problem (complexity)</span>

<span class="sd">        - I recomputed suboptimal solution to the optimization problem, and found the same as in [[&quot;Sparse Stochastic Bandits&quot;, by J. Kwon, V. Perchet &amp; C. Vernade, COLT 2017](https://arxiv.org/abs/1706.01383)].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;sparsity&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sparsity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sparsity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span>
        <span class="k">if</span> <span class="n">sparsity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sparsity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">Policies.OSSB</span> <span class="k">import</span> <span class="n">solve_optimization_problem__sparse_bandits</span>
            <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>  <span class="c1"># WARNING ModuleNotFoundError is only Python 3.6+</span>
                <span class="kn">from</span> <span class="nn">SMPyBandits.Policies.OSSB</span> <span class="k">import</span> <span class="n">solve_optimization_problem__sparse_bandits</span>
            <span class="n">ci</span> <span class="o">=</span> <span class="n">solve_optimization_problem__sparse_bandits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span> <span class="n">sparsity</span><span class="o">=</span><span class="n">sparsity</span><span class="p">,</span> <span class="n">only_strong_or_weak</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># now we use these ci to compute the lower-bound</span>
            <span class="n">gaps</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">]</span>
            <span class="n">lowerbound</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">c</span> <span class="k">for</span> <span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">gaps</span><span class="p">,</span> <span class="n">ci</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>  <span class="c1"># WARNING this is durty!</span>
            <span class="n">lowerbound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">lowerbound</span></div>

<div class="viewcode-block" id="MAB.hoifactor"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.hoifactor">[docs]</a>    <span class="k">def</span> <span class="nf">hoifactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the HOI factor H_OI(mu), the Optimal Arm Identification (OI) factor, for this MAB problem (complexity). Cf. (3.3) in Navikkumar MODI&#39;s thesis, &quot;Machine Learning and Statistical Decision Making for Green Radio&quot; (2017).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">oneHOI</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span></div>

<div class="viewcode-block" id="MAB.lowerbound_multiplayers"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.lowerbound_multiplayers">[docs]</a>    <span class="k">def</span> <span class="nf">lowerbound_multiplayers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute our multi-players lower bound for this MAB problem (complexity), using functions from :mod:`kullback`. &quot;&quot;&quot;</span>
        <span class="n">sortedMeans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nbPlayers</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedMeans</span><span class="p">),</span> <span class="s2">&quot;Error: this lowerbound_multiplayers() for a MAB problem is only valid when there is less users than arms. Here M = </span><span class="si">{}</span><span class="s2"> &gt; K = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedMeans</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
        <span class="c1"># FIXME it is highly suboptimal to have a lowerbound = 0 if nbPlayers == nbArms ! We have to finish the theoretical analysis!</span>
        <span class="n">bestMeans</span> <span class="o">=</span> <span class="n">sortedMeans</span><span class="p">[</span><span class="o">-</span><span class="n">nbPlayers</span><span class="p">:]</span>
        <span class="n">worstMeans</span> <span class="o">=</span> <span class="n">sortedMeans</span><span class="p">[:</span><span class="o">-</span><span class="n">nbPlayers</span><span class="p">]</span>
        <span class="n">worstOfBestMean</span> <span class="o">=</span> <span class="n">bestMeans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Our lower bound is this:</span>
        <span class="n">oneLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">oneLR</span>
        <span class="n">centralized_lowerbound</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">oneLR</span><span class="p">(</span><span class="n">worstOfBestMean</span><span class="p">,</span> <span class="n">oneOfWorstMean</span><span class="p">)</span> <span class="k">for</span> <span class="n">oneOfWorstMean</span> <span class="ow">in</span> <span class="n">worstMeans</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, Anandtharam et al. centralized lower-bound gave = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">centralized_lowerbound</span><span class="p">))</span>  <span class="c1"># DEBUG</span>

        <span class="n">our_lowerbound</span> <span class="o">=</span> <span class="n">nbPlayers</span> <span class="o">*</span> <span class="n">centralized_lowerbound</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, our lower bound gave = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">our_lowerbound</span><span class="p">))</span>  <span class="c1"># DEBUG</span>

        <span class="c1"># The initial lower bound in Theorem 6 from [Anandkumar et al., 2010]</span>
        <span class="n">kl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kl</span>
        <span class="n">anandkumar_lowerbound</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">worstOfBestMean</span> <span class="o">-</span> <span class="n">oneOfWorstMean</span><span class="p">)</span> <span class="o">/</span> <span class="n">kl</span><span class="p">(</span><span class="n">oneOfWorstMean</span><span class="p">,</span> <span class="n">oneOfBestMean</span><span class="p">)</span> <span class="k">for</span> <span class="n">oneOfWorstMean</span> <span class="ow">in</span> <span class="n">worstMeans</span><span class="p">)</span> <span class="k">for</span> <span class="n">oneOfBestMean</span> <span class="ow">in</span> <span class="n">bestMeans</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, the initial lower bound in Theorem 6 from [Anandkumar et al., 2010] gave = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">anandkumar_lowerbound</span><span class="p">))</span>  <span class="c1"># DEBUG</span>

        <span class="c1"># Check that our bound is better (ie bigger)</span>
        <span class="k">if</span> <span class="n">anandkumar_lowerbound</span> <span class="o">&gt;</span> <span class="n">our_lowerbound</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error, our lower bound is worse than the one in Theorem 6 from [Anandkumar et al., 2010], but it should always be better...&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">our_lowerbound</span><span class="p">,</span> <span class="n">anandkumar_lowerbound</span><span class="p">,</span> <span class="n">centralized_lowerbound</span></div>

<div class="viewcode-block" id="MAB.upperbound_collisions"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.upperbound_collisions">[docs]</a>    <span class="k">def</span> <span class="nf">upperbound_collisions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">,</span> <span class="n">times</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute Anandkumar et al. multi-players upper bound for this MAB problem (complexity), for UCB only. Warning: it is HIGHLY asymptotic! &quot;&quot;&quot;</span>
        <span class="n">sortedMeans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">nbPlayers</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedMeans</span><span class="p">),</span> <span class="s2">&quot;Error: this lowerbound_multiplayers() for a MAB problem is only valid when there is less users than arms. Here M = </span><span class="si">{}</span><span class="s2"> &gt; K = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedMeans</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
        <span class="n">bestMeans</span> <span class="o">=</span> <span class="n">sortedMeans</span><span class="p">[</span><span class="o">-</span><span class="n">nbPlayers</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">worstMeans_of_a</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Give the worst min if their is a arms.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">sortedMeans</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="c1"># First, the bound in Lemma 2 from [Anandkumar et al., 2010] uses this Upsilon(U, U)</span>
        <span class="n">Upsilon</span> <span class="o">=</span> <span class="n">binomialCoefficient</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nbPlayers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, Upsilon(M,M) = (2M-1 choose M) = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">Upsilon</span><span class="p">))</span>

        <span class="c1"># First, the constant term</span>
        <span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">pi</span>
        <span class="n">boundOnExpectedTprime_cstTerm</span> <span class="o">=</span> <span class="n">nbPlayers</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span>
                <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mf">3.</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">mu_star_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">worstMeans_of_a</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mu_star_a</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bestMeans</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, the bound with (1 + pi^2 / 3) = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">boundOnExpectedTprime_cstTerm</span><span class="p">))</span>

        <span class="c1"># And the term to multiply with log(t)</span>
        <span class="n">boundOnExpectedTprime_logT</span> <span class="o">=</span> <span class="n">nbPlayers</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="nb">sum</span><span class="p">(</span>
                <span class="mf">8.</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu_star_b</span> <span class="o">-</span> <span class="n">mu_star_a</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">mu_star_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">worstMeans_of_a</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mu_star_a</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bestMeans</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, the bound with (8 / (mu_b^* - mu_a^*)^2) = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">boundOnExpectedTprime_logT</span><span class="p">))</span>

        <span class="c1"># Add them up</span>
        <span class="n">boundOnExpectedTprime</span> <span class="o">=</span> <span class="n">boundOnExpectedTprime_cstTerm</span> <span class="o">+</span> <span class="n">boundOnExpectedTprime_logT</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">times</span><span class="p">)</span>

        <span class="c1"># The upper bound in Theorem 3 from [Anandkumar et al., 2010]</span>
        <span class="n">upperbound</span> <span class="o">=</span> <span class="n">nbPlayers</span> <span class="o">*</span> <span class="p">(</span><span class="n">Upsilon</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">boundOnExpectedTprime</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, Anandkumar et al. upper bound for the total cumulated number of collisions is </span><span class="si">{:.3g}</span><span class="s2"> here ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">upperbound</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>  <span class="c1"># DEBUG</span>

        <span class="k">return</span> <span class="n">upperbound</span></div>

    <span class="c1"># --- Plot methods</span>

<div class="viewcode-block" id="MAB.plotComparison_our_anandkumar"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.plotComparison_our_anandkumar">[docs]</a>    <span class="k">def</span> <span class="nf">plotComparison_our_anandkumar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot a comparison of our lowerbound and their lowerbound.&quot;&quot;&quot;</span>
        <span class="n">nbPlayers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span>
        <span class="n">lowerbounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">):</span>
            <span class="n">lowerbounds</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowerbound_multiplayers</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">nbPlayers</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lowerbounds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;ro-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Besson &amp; Kaufmann lowerbound&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">lowerbounds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;bd-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Anandkumar et al. lowerbound&quot;</span><span class="p">)</span>
        <span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number $M$ of players in the multi-players game</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">signature</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Lowerbound on the centralized cumulative normalized regret&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Comparison of our lowerbound and the one from [Anandkumar et al., 2010].</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> arms: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reprarms</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="n">show_and_save</span><span class="p">(</span><span class="n">showplot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="n">savefig</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">pickleit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

<div class="viewcode-block" id="MAB.plotHistogram"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MAB.plotHistogram">[docs]</a>    <span class="k">def</span> <span class="nf">plotHistogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot a horizon=10000 draws of each arms.&quot;&quot;&quot;</span>
        <span class="n">arms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span>
        <span class="n">rewards</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">arms</span><span class="p">),</span> <span class="n">horizon</span><span class="p">))</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">palette</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arms</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">armId</span><span class="p">,</span> <span class="n">arm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arms</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arm</span><span class="p">,</span> <span class="s1">&#39;draw_nparray&#39;</span><span class="p">):</span>  <span class="c1"># XXX Use this method to speed up computation</span>
                <span class="n">rewards</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span> <span class="o">=</span> <span class="n">arm</span><span class="o">.</span><span class="n">draw_nparray</span><span class="p">((</span><span class="n">horizon</span><span class="p">,))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Slower</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">horizon</span><span class="p">):</span>
                    <span class="n">rewards</span><span class="p">[</span><span class="n">armId</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">arm</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="c1"># Now plot</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">armId</span><span class="p">,</span> <span class="n">arm</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arms</span><span class="p">):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">rewards</span><span class="p">[</span><span class="n">armId</span><span class="p">,</span> <span class="p">:],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">armId</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arm</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Rewards&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Mass repartition of the rewards&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> draws of rewards from these arms.</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> arms: </span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">horizon</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reprarms</span><span class="p">(</span><span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">signature</span><span class="p">))</span>
        <span class="n">show_and_save</span><span class="p">(</span><span class="n">showplot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="n">savefig</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">pickleit</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div></div>


<span class="c1"># --- MarkovianMAB</span>

<span class="n">RESTED</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1">#: Default is rested Markovian.</span>


<div class="viewcode-block" id="dict_of_transition_matrix"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.dict_of_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">dict_of_transition_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert a transition matrix (list of list or numpy array) to a dictionary mapping (state, state) to probabilities (as used by :class:`pykov.Chain`).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]))}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]))}</span></div>


<div class="viewcode-block" id="transition_matrix_of_dict"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.transition_matrix_of_dict">[docs]</a><span class="k">def</span> <span class="nf">transition_matrix_of_dict</span><span class="p">(</span><span class="n">dic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert a dictionary mapping (state, state) to probabilities (as used by :class:`pykov.Chain`) to a transition matrix (numpy array).&quot;&quot;&quot;</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dic</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">xkeys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">({</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}))</span>
    <span class="n">ykeys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">({</span><span class="n">j</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">dic</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xkeys</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ykeys</span><span class="p">])</span></div>


<div class="viewcode-block" id="MarkovianMAB"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MarkovianMAB">[docs]</a><span class="k">class</span> <span class="nc">MarkovianMAB</span><span class="p">(</span><span class="n">MAB</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Classic MAB problem but the rewards are drawn from a rested/restless Markov chain.</span>

<span class="sd">    - configuration is a dict with ``rested`` and ``transitions`` keys.</span>
<span class="sd">    - ``rested`` is a Boolean. See [Kalathil et al., 2012](https://arxiv.org/abs/1206.3582) page 2 for a description.</span>
<span class="sd">    - ``transitions`` is list of K transition matrices *or* dictionary (to specify non-integer states), one for each arm.</span>

<span class="sd">    Example::</span>

<span class="sd">        configuration = {</span>
<span class="sd">            &quot;arm_type&quot;: &quot;Markovian&quot;,</span>
<span class="sd">            &quot;params&quot;: {</span>
<span class="sd">                &quot;rested&quot;: True,  # or False</span>
<span class="sd">                # Example from [Kalathil et al., 2012](https://arxiv.org/abs/1206.3582) Table 1</span>
<span class="sd">                &quot;transitions&quot;: [</span>
<span class="sd">                    # 1st arm, Either a dictionary</span>
<span class="sd">                    {   # Mean = 0.375</span>
<span class="sd">                        (0, 0): 0.7, (0, 1): 0.3,</span>
<span class="sd">                        (1, 0): 0.5, (1, 1): 0.5,</span>
<span class="sd">                    },</span>
<span class="sd">                    # 2nd arm, Or a right transition matrix</span>
<span class="sd">                    [[0.2, 0.8], [0.6, 0.4]],  # Mean = 0.571</span>
<span class="sd">                ],</span>
<span class="sd">                # FIXME make this by default! include it in MAB.py and not in the configuration!</span>
<span class="sd">                &quot;steadyArm&quot;: Bernoulli</span>
<span class="sd">            }</span>
<span class="sd">        }</span>

<span class="sd">    - This class requires the [pykov](https://github.com/riccardoscalco/Pykov) module to represent and use Markov chain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MarkovianMAB.__init__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MarkovianMAB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;New MarkovianMAB.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">Creating a new MarkovianMAB problem ...&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isChangingAtEachRepetition</span>   <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: The problem is not changing at each repetition.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isDynamic</span>   <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: The problem is static.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isMarkovian</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1">#: The problem is Markovian.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Error: &#39;configuration&#39; for a MarkovianMAB must be a dictionary.&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="k">assert</span> <span class="s2">&quot;params&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="s2">&quot;transitions&quot;</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> \
            <span class="s2">&quot;Error: &#39;configuration.params&#39; for a MarkovianMAB must be a dictionary with keys &#39;transition&#39; and &#39;rested&#39;.&quot;</span>
        <span class="c1"># Use input configuration</span>
        <span class="n">transitions</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="s2">&quot;transitions&quot;</span><span class="p">]</span>
        <span class="n">dict_transitions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">matrix_transitions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">dict_transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">matrix_transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transition_matrix_of_dict</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dict_transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dict_of_transition_matrix</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                <span class="n">matrix_transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_transitions</span> <span class="o">=</span> <span class="n">matrix_transitions</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - Using these transition matrices:&quot;</span><span class="p">,</span> <span class="n">matrix_transitions</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict_transitions</span> <span class="o">=</span> <span class="n">dict_transitions</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - Using these transition dictionaries:&quot;</span><span class="p">,</span> <span class="n">dict_transitions</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="c1"># FIXED this will fail harshly if Pykov is not installed/present</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chains</span> <span class="o">=</span> <span class="p">[</span><span class="n">Chain</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dict_transitions</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - For these Markov chains:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rested</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;rested&quot;</span><span class="p">,</span> <span class="n">RESTED</span><span class="p">)</span>  <span class="c1">#: Rested or not Markovian model?</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - Rested:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rested</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix_transitions</span><span class="p">)</span>  <span class="c1">#: Number of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;nbArms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="c1"># # Make every transition matrix a right stochastic transition matrix</span>
        <span class="c1"># for c in self.chains:</span>
        <span class="c1">#     c.stochastic()</span>

        <span class="c1"># Means of arms = steady distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">states</span><span class="p">()))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - and states:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steadys</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">steady</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">steady</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;[ERROR] the steady state of the Markov chain </span><span class="si">{}</span><span class="s2"> was not-found because it is non-ergodic...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The Markov chain </span><span class="si">{}</span><span class="s2"> is non-ergodic, and so does not have a steady state distribution... Please choose another transition matrix that as to be irreducible, aperiodic, and reversible.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="c1"># If the steady state exist, go on</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - and steady state distributions:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steadys</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steadys</span><span class="p">)])</span>  <span class="c1">#: Means of each arms, from their steady distributions.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - so it gives arms of means:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arms</span> <span class="o">=</span> <span class="p">[</span><span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="s2">&quot;steadyArm&quot;</span><span class="p">](</span><span class="n">mean</span><span class="p">)</span> <span class="k">for</span> <span class="n">mean</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - so arms asymptotically equivalent to:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - represented as:&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reprarms</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1">#: Max mean of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;maxArm&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1">#: Min mean of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;minArm&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="c1">#: States of each arm, initially they are all busy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DONE for creating this MarkovianMAB problem...&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span></div>

<div class="viewcode-block" id="MarkovianMAB.__repr__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MarkovianMAB.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(nbArms: </span><span class="si">{}</span><span class="s2">, chains: </span><span class="si">{}</span><span class="s2">, arms: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_transitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span></div>

<div class="viewcode-block" id="MarkovianMAB.reprarms"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MarkovianMAB.reprarms">[docs]</a>    <span class="k">def</span> <span class="nf">reprarms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">openTag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">endTag</span><span class="o">=</span><span class="s1">&#39;^*&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a str representation of the list of the arms (like `repr(self.arms)` but better).</span>

<span class="sd">        - For Markovian MAB, the chain and the steady Bernoulli arm is represented.</span>
<span class="sd">        - If nbPlayers &gt; 0, it surrounds the representation of the best arms by openTag, endTag (for plot titles, in a multi-player setting).</span>

<span class="sd">        - Example: openTag = &#39;&#39;, endTag = &#39;^*&#39; for LaTeX tags to put a star exponent.</span>
<span class="sd">        - Example: openTag = &#39;&lt;red&gt;&#39;, endTag = &#39;&lt;/red&gt;&#39; for HTML-like tags.</span>
<span class="sd">        - Example: openTag = r&#39;\textcolor{red}{&#39;, endTag = &#39;}&#39; for LaTeX tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nbPlayers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix_transitions</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">nbPlayers</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Error, the &#39;nbPlayers&#39; argument for reprarms method of a MAB object has to be a non-negative integer.&quot;</span>  <span class="c1"># DEBUG</span>
            <span class="n">means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span>
            <span class="n">bestArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">means</span><span class="p">)[</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">):]</span>
            <span class="k">if</span> <span class="n">nbPlayers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="n">bestArms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">dollar</span> <span class="o">=</span> <span class="s1">&#39;$&#39;</span> <span class="k">if</span> <span class="n">latex</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="n">text</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> Markovian rewards, </span><span class="si">{}</span><span class="s1">[</span><span class="si">{}</span><span class="s1">]</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s2">&quot;Rested&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rested</span> <span class="k">else</span> <span class="s2">&quot;Restless&quot;</span><span class="p">,</span>
                <span class="n">dollar</span><span class="p">,</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">P: </span><span class="si">{}</span><span class="s2">, \pi: </span><span class="si">{}</span><span class="s2"> âˆ¼ </span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">openTag</span> <span class="k">if</span> <span class="n">armId</span> <span class="ow">in</span> <span class="n">bestArms</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">st</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arm</span><span class="p">),</span>
                        <span class="n">endTag</span> <span class="k">if</span> <span class="n">armId</span> <span class="ow">in</span> <span class="n">bestArms</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">armId</span><span class="p">,</span> <span class="p">(</span><span class="n">arm</span><span class="p">,</span> <span class="n">mat</span><span class="p">,</span> <span class="n">st</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_transitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">steadys</span><span class="p">))</span>
                <span class="p">),</span> <span class="n">dollar</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">wraplatex</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">if</span> <span class="n">latex</span> <span class="k">else</span> <span class="n">wraptext</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>

<div class="viewcode-block" id="MarkovianMAB.draw"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.MarkovianMAB.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">armId</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Move on the Markov chain and return its state as a reward (0 or 1, or else).</span>

<span class="sd">        - If *rested* Markovian, only the state of the Markov chain of arm `armId` changes. It is the simpler model, and the default model.</span>
<span class="sd">        - But if *restless* (non rested) Markovian, the states of all the Markov chain of all arms change (not only `armId`).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 1. Get current state for that arm, and its Markov chain</span>
        <span class="n">state</span><span class="p">,</span> <span class="n">chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">armId</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span>
        <span class="c1"># 2. Sample from that Markov chain</span>
        <span class="n">nextState</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># 3. Update the state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextState</span>
        <span class="c1"># print(&quot;- For the arm #{}, previously in the state {}, the Markov chain moved to state {} ...&quot;.format(armId, state, nextState))  # DEBUG</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">rested</span><span class="p">:</span>
            <span class="c1"># print(&quot;- Non-rested Markovian model, every other arm is also moving...&quot;)  # DEBUG</span>
            <span class="k">for</span> <span class="n">armId2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">):</span>
                <span class="c1"># For each other arm, they evolve</span>
                <span class="k">if</span> <span class="n">armId2</span> <span class="o">!=</span> <span class="n">armId</span><span class="p">:</span>
                    <span class="n">state</span><span class="p">,</span> <span class="n">chain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">armId2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">chains</span><span class="p">[</span><span class="n">armId2</span><span class="p">]</span>
                    <span class="n">nextState</span> <span class="o">=</span> <span class="n">chain</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                    <span class="c1"># print(&quot;    - For the arm #{}, previously in the state {}, the Markov chain moved to state {} ...&quot;.format(armId, state, nextState))  # DEBUG</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">armId2</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextState</span>

        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">nextState</span><span class="p">)</span></div></div>


<span class="c1"># --- ChangingAtEachRepMAB</span>

<span class="n">VERBOSE</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">VERBOSE</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: Whether to be verbose when generating new arms for Dynamic MAB</span>

<div class="viewcode-block" id="ChangingAtEachRepMAB"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB">[docs]</a><span class="k">class</span> <span class="nc">ChangingAtEachRepMAB</span><span class="p">(</span><span class="n">MAB</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Like a stationary MAB problem, but the arms are (randomly) regenerated for each repetition, with the :meth:`newRandomArms` method.</span>

<span class="sd">    - ``M.arms`` and ``M.means`` is changed after each call to :meth:`newRandomArms`, but not ``nbArm``. All the other methods are carefully written to still make sense (``Mbest``, ``Mworst``, ``minArm``, ``maxArm``).</span>

<span class="sd">    .. warning:: It works perfectly fine, but it is still experimental, be careful when using this feature.</span>

<span class="sd">    .. note:: Testing bandit algorithms against randomly generated problems at each repetitions is usually referred to as *&quot;Bayesian problems&quot;* in the literature: a prior is set on problems (eg. uniform on :math:`[0,1]^K` or less obvious for instance if a ``mingap`` is set), and the performance is assessed against this prior. It differs from the *frequentist* point of view of having one fixed problem and doing eg. ``n=1000`` repetitions on the same problem.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="ChangingAtEachRepMAB.__init__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">VERBOSE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;New ChangingAtEachRepMAB.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isChangingAtEachRepetition</span>   <span class="o">=</span> <span class="kc">True</span>  <span class="c1">#: The problem is changing at each repetition or not.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isDynamic</span>   <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: The problem is static.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isMarkovian</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: The problem is not Markovian.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="s2">&quot;arm_type&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> <span class="ow">and</span> <span class="s2">&quot;params&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> \
            <span class="ow">and</span> <span class="s2">&quot;newMeans&quot;</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span> <span class="ow">and</span> <span class="s2">&quot;args&quot;</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> \
            <span class="s2">&quot;Error: this ChangingAtEachRepMAB is not really a dynamic MAB, you should use a simple MAB instead!&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Special MAB problem, changing at every repetitions, read from a dictionnary &#39;configuration&#39; = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">configuration</span><span class="p">))</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arm_type</span> <span class="o">=</span> <span class="n">arm_type</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;arm_type&quot;</span><span class="p">]</span>  <span class="c1">#: Kind of arm (ChangingAtEachRepMAB are homogeneous)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;arm_type&#39; =&quot;</span><span class="p">,</span> <span class="n">arm_type</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;params&#39; =&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newMeans</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;newMeans&quot;</span><span class="p">]</span>  <span class="c1">#: Function to generate the means</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;newMeans&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newMeans</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span>  <span class="c1">#: Args to give to function</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;args&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="c1"># XXX try to read sparsity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;sparsity&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;sparsity&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ==&gt; Creating the dynamic arms ...&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="c1"># Keep track of the successive mean vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Historic of the means vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># nb of calls to the function for generating new arms</span>
        <span class="c1"># Generate a first mean vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newRandomArms</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - drawing a random set of arms&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>  <span class="c1">#: Means of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - with &#39;nbArms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - with &#39;arms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - Example of initial draw of &#39;means&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - with &#39;maxArm&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - with &#39;minArm&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span><span class="p">)</span>  <span class="c1"># DEBUG</span></div>

<div class="viewcode-block" id="ChangingAtEachRepMAB.__repr__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(nbArms: </span><span class="si">{}</span><span class="s2">, arms: </span><span class="si">{}</span><span class="s2">, minArm: </span><span class="si">{:.3g}</span><span class="s2">, maxArm: </span><span class="si">{:.3g}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minArm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxArm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(nbArms: </span><span class="si">{}</span><span class="s2">, armType: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arm_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChangingAtEachRepMAB.reprarms"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.reprarms">[docs]</a>    <span class="k">def</span> <span class="nf">reprarms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">openTag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">endTag</span><span class="o">=</span><span class="s1">&#39;^*&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cannot represent the dynamic arms, so print the ChangingAtEachRepMAB object&quot;&quot;&quot;</span>
        <span class="c1"># print(&quot;reprarms of a ChangingAtEachRepMAB object...&quot;)  # DEBUG</span>
        <span class="c1"># print(&quot;  It has self._historyOfMeans =\n{}&quot;.format(self._historyOfMeans))  # DEBUG</span>
        <span class="c1"># print(&quot;  It has self.means =\n{}&quot;.format(self.means))  # DEBUG</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{text}</span><span class="s2">, </span><span class="si">{K}</span><span class="s2"> with uniform means on [</span><span class="si">{dollar}{lower:.3g}</span><span class="s2">, </span><span class="si">{upper:.3g}{dollar}</span><span class="s2">]</span><span class="si">{mingap}{sparsity}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Bayesian MAB&quot;</span><span class="p">,</span>
            <span class="n">K</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">],</span>
            <span class="n">upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;amplitude&quot;</span><span class="p">],</span>
            <span class="n">mingap</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;mingap&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;mingap&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="sa">r</span><span class="s2">&quot;, min gap=$</span><span class="si">%.3g</span><span class="s2">$&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;mingap&quot;</span><span class="p">],</span>
            <span class="n">sparsity</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;, sparsity = </span><span class="si">{dollar}{s}{dollar}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span><span class="p">,</span> <span class="n">dollar</span><span class="o">=</span><span class="s2">&quot;$&quot;</span> <span class="k">if</span> <span class="n">latex</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
            <span class="n">dollar</span><span class="o">=</span><span class="s2">&quot;$&quot;</span> <span class="k">if</span> <span class="n">latex</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wraptext</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># --- Dynamic arms and means</span>

<div class="viewcode-block" id="ChangingAtEachRepMAB.newRandomArms"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.newRandomArms">[docs]</a>    <span class="k">def</span> <span class="nf">newRandomArms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">VERBOSE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a new list of arms, from ``arm_type(params[&#39;newMeans&#39;](*params[&#39;args&#39;]))``.&quot;&quot;&quot;</span>
        <span class="n">one_draw_of_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newMeans</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arms</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arm_type</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="k">for</span> <span class="n">mean</span> <span class="ow">in</span> <span class="n">one_draw_of_means</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arms</span><span class="p">)</span>  <span class="c1"># useless</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># new draw!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one_draw_of_means</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  - Creating a new dynamic list of means = </span><span class="si">{}</span><span class="s2"> for arms: ChangingAtEachRepMAB = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">one_draw_of_means</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>  <span class="c1"># DEBUG</span>
            <span class="c1"># print(&quot;Currently self._t = {} and self._historyOfMeans = {} ...&quot;.format(self._t, self._historyOfMeans))  # DEBUG</span>
        <span class="k">return</span> <span class="n">one_draw_of_means</span></div>

    <span class="c1"># All these properties arms, means, minArm, maxArm cannot be attributes, as the means of arms change at every experiments</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">arms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the *current* list of arms.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">means</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the list of means of arms for this ChangingAtEachRepMAB: after :math:`x` calls to :meth:`newRandomArms`, the return mean of arm :math:`k` is the mean of the :math:`x` means of that arm.</span>

<span class="sd">        .. warning:: Highly experimental!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># --- Helper to compute sets Mbest and Mworst</span>

<div class="viewcode-block" id="ChangingAtEachRepMAB.Mbest"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.Mbest">[docs]</a>    <span class="k">def</span> <span class="nf">Mbest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set of M best means (averaged on all the draws of new means).&quot;&quot;&quot;</span>
        <span class="n">sortedMeans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sortedMeans</span><span class="p">[</span><span class="o">-</span><span class="n">M</span><span class="p">:]</span></div>

<div class="viewcode-block" id="ChangingAtEachRepMAB.Mworst"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.Mworst">[docs]</a>    <span class="k">def</span> <span class="nf">Mworst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Set of M worst means (averaged on all the draws of new means).&quot;&quot;&quot;</span>
        <span class="n">sortedMeans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sortedMeans</span><span class="p">[:</span><span class="o">-</span><span class="n">M</span><span class="p">]</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minArm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the smallest mean of the arms, for a dynamic MAB (averaged on all the draws of new means).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">maxArm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the largest mean of the arms, for a dynamic MAB (averaged on all the draws of new means).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">)))</span>

    <span class="c1">#</span>
    <span class="c1"># --- Compute lower bounds</span>

<div class="viewcode-block" id="ChangingAtEachRepMAB.lowerbound"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.lowerbound">[docs]</a>    <span class="k">def</span> <span class="nf">lowerbound</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the constant C(mu), for [Lai &amp; Robbins] lower-bound for this MAB problem (complexity), using functions from :mod:`kullback` (averaged on all the draws of new means).&quot;&quot;&quot;</span>
        <span class="n">oneLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">oneLR</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span>
                        <span class="nb">sum</span><span class="p">(</span>
                            <span class="n">oneLR</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">means</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">means</span>
                            <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">means</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span>
                        <span class="p">])</span></div>

<div class="viewcode-block" id="ChangingAtEachRepMAB.hoifactor"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.hoifactor">[docs]</a>    <span class="k">def</span> <span class="nf">hoifactor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute the HOI factor H_OI(mu), the Optimal Arm Identification (OI) factor, for this MAB problem (complexity). Cf. (3.3) in Navikkumar MODI&#39;s thesis, &quot;Machine Learning and Statistical Decision Making for Green Radio&quot; (2017) (averaged on all the draws of new means).&quot;&quot;&quot;</span>
        <span class="n">oneHOI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">oneHOI</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span>
                        <span class="nb">sum</span><span class="p">(</span>
                            <span class="n">oneHOI</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">means</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">means</span>
                            <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">means</span><span class="p">)</span>
                        <span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">means</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">means</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span>
                        <span class="p">])</span></div>

<div class="viewcode-block" id="ChangingAtEachRepMAB.lowerbound_multiplayers"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.ChangingAtEachRepMAB.lowerbound_multiplayers">[docs]</a>    <span class="k">def</span> <span class="nf">lowerbound_multiplayers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Compute our multi-players lower bound for this MAB problem (complexity), using functions from :mod:`kullback`. &quot;&quot;&quot;</span>
        <span class="n">oneLR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">oneLR</span>
        <span class="n">kl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kl</span>

        <span class="n">avg_our_lowerbound</span><span class="p">,</span> <span class="n">avg_anandkumar_lowerbound</span><span class="p">,</span> <span class="n">avg_centralized_lowerbound</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">means</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">:</span>
            <span class="n">sortedMeans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">nbPlayers</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedMeans</span><span class="p">),</span> <span class="s2">&quot;Error: this lowerbound_multiplayers() for a MAB problem is only valid when there is less users than arms. Here M = </span><span class="si">{}</span><span class="s2"> &gt; K = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedMeans</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
            <span class="c1"># FIXME it is highly suboptimal to have a lowerbound = 0 if nbPlayers == nbArms ! We have to finish the theoretical analysis!</span>
            <span class="n">bestMeans</span> <span class="o">=</span> <span class="n">sortedMeans</span><span class="p">[</span><span class="o">-</span><span class="n">nbPlayers</span><span class="p">:]</span>
            <span class="n">worstMeans</span> <span class="o">=</span> <span class="n">sortedMeans</span><span class="p">[:</span><span class="o">-</span><span class="n">nbPlayers</span><span class="p">]</span>
            <span class="n">worstOfBestMean</span> <span class="o">=</span> <span class="n">bestMeans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Our lower bound is this:</span>
            <span class="n">centralized_lowerbound</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">oneLR</span><span class="p">(</span><span class="n">worstOfBestMean</span><span class="p">,</span> <span class="n">oneOfWorstMean</span><span class="p">)</span> <span class="k">for</span> <span class="n">oneOfWorstMean</span> <span class="ow">in</span> <span class="n">worstMeans</span><span class="p">)</span>

            <span class="n">our_lowerbound</span> <span class="o">=</span> <span class="n">nbPlayers</span> <span class="o">*</span> <span class="n">centralized_lowerbound</span>

            <span class="c1"># The initial lower bound in Theorem 6 from [Anandkumar et al., 2010]</span>
            <span class="n">anandkumar_lowerbound</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">sum</span><span class="p">((</span><span class="n">worstOfBestMean</span> <span class="o">-</span> <span class="n">oneOfWorstMean</span><span class="p">)</span> <span class="o">/</span> <span class="n">kl</span><span class="p">(</span><span class="n">oneOfWorstMean</span><span class="p">,</span> <span class="n">oneOfBestMean</span><span class="p">)</span> <span class="k">for</span> <span class="n">oneOfWorstMean</span> <span class="ow">in</span> <span class="n">worstMeans</span><span class="p">)</span> <span class="k">for</span> <span class="n">oneOfBestMean</span> <span class="ow">in</span> <span class="n">bestMeans</span><span class="p">)</span>

            <span class="c1"># Store them</span>
            <span class="n">avg_our_lowerbound</span> <span class="o">+=</span> <span class="n">our_lowerbound</span>
            <span class="n">avg_anandkumar_lowerbound</span> <span class="o">+=</span> <span class="n">anandkumar_lowerbound</span>
            <span class="n">avg_centralized_lowerbound</span> <span class="o">+=</span> <span class="n">centralized_lowerbound</span>

        <span class="c1"># Done, compute the averages of the lower-bounds</span>
        <span class="n">avg_our_lowerbound</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">))</span>
        <span class="n">avg_anandkumar_lowerbound</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">))</span>
        <span class="n">avg_centralized_lowerbound</span> <span class="o">/=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">))</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, Anandtharam et al. centralized lower-bound gave = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">avg_centralized_lowerbound</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, our lower bound gave = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">avg_our_lowerbound</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; -  For </span><span class="si">{}</span><span class="s2"> players, the initial lower bound in Theorem 6 from [Anandkumar et al., 2010] gave = </span><span class="si">{:.3g}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nbPlayers</span><span class="p">,</span> <span class="n">avg_anandkumar_lowerbound</span><span class="p">))</span>  <span class="c1"># DEBUG</span>

        <span class="c1"># Check that our bound is better (ie bigger)</span>
        <span class="k">if</span> <span class="n">avg_anandkumar_lowerbound</span> <span class="o">&gt;</span> <span class="n">avg_our_lowerbound</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error, our lower bound is worse than the one in Theorem 6 from [Anandkumar et al., 2010], but it should always be better...&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">avg_our_lowerbound</span><span class="p">,</span> <span class="n">avg_anandkumar_lowerbound</span><span class="p">,</span> <span class="n">avg_centralized_lowerbound</span></div></div>


<span class="c1"># --- PieceWiseStationaryMAB</span>

<div class="viewcode-block" id="PieceWiseStationaryMAB"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB">[docs]</a><span class="k">class</span> <span class="nc">PieceWiseStationaryMAB</span><span class="p">(</span><span class="n">MAB</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Like a stationary MAB problem, but piece-wise stationary.</span>

<span class="sd">    - Give it a list of vector of means, and a list of change-point locations.</span>

<span class="sd">    - You can use :meth:`plotHistoryOfMeans` to see a nice plot of the history of means.</span>

<span class="sd">    .. note:: This is a generic class to implement one &quot;easy&quot; kind of non-stationary bandits, abruptly changing non-stationary bandits, if changepoints are fixed and decided in advanced.</span>

<span class="sd">    .. warning:: It works fine, but it is still experimental, be careful when using this feature.</span>

<span class="sd">    .. warning:: The number of arms is fixed, see https://github.com/SMPyBandits/SMPyBandits/issues/123 if you are curious about bandit problems with a varying number of arms (or sleeping bandits where some arms can be enabled or disabled at each time).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PieceWiseStationaryMAB.__init__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">VERBOSE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;New PieceWiseStationaryMAB.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isChangingAtEachRepetition</span>   <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: The problem is not changing at each repetition.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isDynamic</span>   <span class="o">=</span> <span class="kc">True</span>  <span class="c1">#: The problem is dynamic.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isMarkovian</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: The problem is not Markovian.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="s2">&quot;arm_type&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> <span class="ow">and</span> <span class="s2">&quot;params&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> \
            <span class="ow">and</span> <span class="s2">&quot;listOfMeans&quot;</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span> \
            <span class="ow">and</span> <span class="s2">&quot;changePoints&quot;</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> \
            <span class="s2">&quot;Error: this PieceWiseStationaryMAB is not really a non-stationary MAB, you should use a simple MAB instead!&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Special MAB problem, with arm (possibly) changing at every time step, read from a dictionnary &#39;configuration&#39; = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">configuration</span><span class="p">))</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arm_type</span> <span class="o">=</span> <span class="n">arm_type</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;arm_type&quot;</span><span class="p">]</span>  <span class="c1">#: Kind of arm (PieceWiseStationaryMAB are homogeneous)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;arm_type&#39; =&quot;</span><span class="p">,</span> <span class="n">arm_type</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;params&#39; =&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;listOfMeans&quot;</span><span class="p">]</span>  <span class="c1">#: The list of means</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1">#: Number of arms</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arms</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span> <span class="k">for</span> <span class="n">arms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">),</span> <span class="s2">&quot;Error: the number of arms cannot be different between change-points.&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;listOfMeans&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;changePoints&quot;</span><span class="p">]</span>  <span class="c1">#: List of the change points</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;changePoints&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="c1"># XXX Maybe we need to add 0 in the list of changePoints</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">),</span> <span class="s2">&quot;Error: the list of means </span><span class="si">{}</span><span class="s2"> does not has the same length as the list of change points </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="c1"># XXX try to read sparsity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;sparsity&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;sparsity&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ==&gt; Creating the dynamic arms ...&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">listOfArms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arm_type</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="k">for</span> <span class="n">mean</span> <span class="ow">in</span> <span class="n">means</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">means</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># current number of the interval we are in</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - with &#39;nbArms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - with &#39;arms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - Initial draw of &#39;means&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1"># DEBUG</span></div>

<div class="viewcode-block" id="PieceWiseStationaryMAB.__repr__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listOfArms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(nbArms: </span><span class="si">{}</span><span class="s2">, arms: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(nbArms: </span><span class="si">{}</span><span class="s2">, armType: </span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arm_type</span><span class="p">)</span></div>

<div class="viewcode-block" id="PieceWiseStationaryMAB.reprarms"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB.reprarms">[docs]</a>    <span class="k">def</span> <span class="nf">reprarms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">openTag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">endTag</span><span class="o">=</span><span class="s1">&#39;^*&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cannot represent the dynamic arms, so print the PieceWiseStationaryMAB object&quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;</span><span class="si">{text}</span><span class="s2">, </span><span class="si">{arm}</span><span class="s2"> with $\Upsilon=</span><span class="si">{M}</span><span class="s2">$ break-points&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Non-Stationary MAB&quot;</span><span class="p">,</span>
            <span class="n">arm</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">M</span><span class="o">=</span><span class="nb">len</span><span class="p">([</span><span class="n">tau</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span> <span class="k">if</span> <span class="n">tau</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]),</span>
            <span class="c1"># we do not count 0 and horizon</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wraptext</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>

<div class="viewcode-block" id="PieceWiseStationaryMAB.newRandomArms"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB.newRandomArms">[docs]</a>    <span class="k">def</span> <span class="nf">newRandomArms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">onlyOneArm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">VERBOSE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Fake function, there is nothing random here, it is just to tell the piece-wise stationary MAB problem to maybe use the next interval.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - BREAKPOINT For a PieceWiseStationaryMAB object, the function newRandomArms was called, with t = </span><span class="si">{}</span><span class="s2">, and current interval was </span><span class="si">{}</span><span class="s2">, so means was = </span><span class="si">{}</span><span class="s2"> and will be = </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>  <span class="c1"># DEBUG</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># next interval!</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  - For a PieceWiseStationaryMAB object, the function newRandomArms was called, with t = </span><span class="si">{}</span><span class="s2">, and current interval is </span><span class="si">{}</span><span class="s2">, so means is = </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span><span class="p">]))</span>  <span class="c1"># DEBUG</span>
        <span class="c1"># return the latest generate means</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span><span class="p">]</span></div>

    <span class="c1"># --- Plot utility</span>

<div class="viewcode-block" id="PieceWiseStationaryMAB.plotHistoryOfMeans"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB.plotHistoryOfMeans">[docs]</a>    <span class="k">def</span> <span class="nf">plotHistoryOfMeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">forceTo01</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">showplot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pickleit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the history of means, as a plot with x axis being the time, y axis the mean rewards, and K curves one for each arm.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">horizon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">horizon</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span>
        <span class="n">allMeans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_allMeans</span><span class="p">(</span><span class="n">horizon</span><span class="o">=</span><span class="n">horizon</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">palette</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>
        <span class="n">markers</span> <span class="o">=</span> <span class="n">makemarkers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>
        <span class="c1"># Now plot</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">armId</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">):</span>
            <span class="n">meanOfThisArm</span> <span class="o">=</span> <span class="n">allMeans</span><span class="p">[</span><span class="n">armId</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">meanOfThisArm</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">armId</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="n">markers</span><span class="p">[</span><span class="n">armId</span><span class="p">],</span> <span class="n">markevery</span><span class="o">=</span><span class="p">(</span><span class="n">armId</span> <span class="o">/</span> <span class="mf">50.</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Arm #</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">armId</span><span class="p">),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="n">legend</span><span class="p">()</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">forceTo01</span><span class="p">:</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: Adding vlines for the change points with more than 20 change points will be ugly on the plots...&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>  <span class="c1"># add the vlines only if not too many change points</span>
            <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tau</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tau</span> <span class="o">&lt;</span> <span class="n">horizon</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Time steps $t = 1...T$, horizon $T = </span><span class="si">{}</span><span class="s2">$</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">horizon</span><span class="p">,</span> <span class="n">signature</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;Successive means of the $K = </span><span class="si">{}</span><span class="s2">$ arms&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;History of means for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reprarms</span><span class="p">(</span><span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="n">show_and_save</span><span class="p">(</span><span class="n">showplot</span><span class="o">=</span><span class="n">showplot</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="n">savefig</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">pickleit</span><span class="o">=</span><span class="n">pickleit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fig</span></div>

    <span class="c1"># All these properties arms, means, minArm, maxArm cannot be attributes, as the means of arms change at every experiments</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">arms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the *current* list of arms. at time :math:`t` , the return mean of arm :math:`k` is the mean during the time interval containing :math:`t`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfArms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">means</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the list of means of arms for this PieceWiseStationaryMAB: at time :math:`t` , the return mean of arm :math:`k` is the mean during the time interval containing :math:`t`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">currentInterval</span><span class="p">]</span>

    <span class="c1">#</span>
    <span class="c1"># --- Helper to compute values minArm and maxArm</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">minArm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the smallest mean of the arms, for the current vector of means.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">maxArm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the largest mean of the arms, for the current vector of means.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># --- Helper to compute vector of min arms, max arms, all arms</span>

<div class="viewcode-block" id="PieceWiseStationaryMAB.get_minArm"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB.get_minArm">[docs]</a>    <span class="k">def</span> <span class="nf">get_minArm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the smallest mean of the arms, for a piece-wise stationary MAB</span>

<span class="sd">        - It is a vector of length horizon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">horizon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">horizon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span>
        <span class="n">mapOfMinArms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">means</span><span class="p">)</span> <span class="k">for</span> <span class="n">means</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">]</span>
        <span class="n">meansOfMinArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">horizon</span><span class="p">)</span>
        <span class="n">nbChangePoint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">horizon</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nbChangePoint</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">[</span><span class="n">nbChangePoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">nbChangePoint</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">meansOfMinArms</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapOfMinArms</span><span class="p">[</span><span class="n">nbChangePoint</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">meansOfMinArms</span></div>

<div class="viewcode-block" id="PieceWiseStationaryMAB.get_maxArm"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB.get_maxArm">[docs]</a>    <span class="k">def</span> <span class="nf">get_maxArm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vector of max mean of the arms, for a piece-wise stationary MAB.</span>

<span class="sd">        - It is a vector of length horizon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">horizon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">horizon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span>
        <span class="n">mapOfMaxArms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">means</span><span class="p">)</span> <span class="k">for</span> <span class="n">means</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">]</span>
        <span class="n">meansOfMaxArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">horizon</span><span class="p">)</span>
        <span class="n">nbChangePoint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">horizon</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nbChangePoint</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">[</span><span class="n">nbChangePoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">nbChangePoint</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">meansOfMaxArms</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapOfMaxArms</span><span class="p">[</span><span class="n">nbChangePoint</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">meansOfMaxArms</span></div>

<div class="viewcode-block" id="PieceWiseStationaryMAB.get_allMeans"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.PieceWiseStationaryMAB.get_allMeans">[docs]</a>    <span class="k">def</span> <span class="nf">get_allMeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vector of mean of the arms, for a piece-wise stationary MAB.</span>

<span class="sd">        - It is a numpy array of shape (nbArms, horizon).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">horizon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">horizon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span>
        <span class="n">meansOfArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">horizon</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">armId</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">):</span>
            <span class="n">nbChangePoint</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">horizon</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nbChangePoint</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">[</span><span class="n">nbChangePoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">nbChangePoint</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">meansOfArms</span><span class="p">[</span><span class="n">armId</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listOfMeans</span><span class="p">[</span><span class="n">nbChangePoint</span><span class="p">][</span><span class="n">armId</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">meansOfArms</span></div></div>

    <span class="c1">#</span>
    <span class="c1"># --- Compute lower bounds</span>
    <span class="c1"># TODO include knowledge of piece-wise stationarity in the lower-bounds</span>

    <span class="c1"># def lowerbound(self):</span>
    <span class="c1">#     &quot;&quot;&quot; Compute the constant C(mu), for [Lai &amp; Robbins] lower-bound for this MAB problem (complexity), using functions from :mod:`kullback` (averaged on all the draws of new means).&quot;&quot;&quot;</span>
    <span class="c1">#     raise NotImplementedError</span>

    <span class="c1"># def hoifactor(self):</span>
    <span class="c1">#     &quot;&quot;&quot; Compute the HOI factor H_OI(mu), the Optimal Arm Identification (OI) factor, for this MAB problem (complexity). Cf. (3.3) in Navikkumar MODI&#39;s thesis, &quot;Machine Learning and Statistical Decision Making for Green Radio&quot; (2017) (averaged on all the draws of new means).&quot;&quot;&quot;</span>
    <span class="c1">#     raise NotImplementedError</span>

    <span class="c1"># def lowerbound_multiplayers(self, nbPlayers=1):</span>
    <span class="c1">#     &quot;&quot;&quot; Compute our multi-players lower bound for this MAB problem (complexity), using functions from :mod:`kullback`. &quot;&quot;&quot;</span>
    <span class="c1">#     raise NotImplementedError</span>


<span class="c1"># --- PieceWiseStationaryMAB</span>

<div class="viewcode-block" id="NonStationaryMAB"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.NonStationaryMAB">[docs]</a><span class="k">class</span> <span class="nc">NonStationaryMAB</span><span class="p">(</span><span class="n">PieceWiseStationaryMAB</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Like a stationary MAB problem, but the arms *can* be modified *at each time step*, with the :meth:`newRandomArms` method.</span>

<span class="sd">    - ``M.arms`` and ``M.means`` is changed after each call to :meth:`newRandomArms`, but not ``nbArm``. All the other methods are carefully written to still make sense (``Mbest``, ``Mworst``, ``minArm``, ``maxArm``).</span>

<span class="sd">    .. note:: This is a generic class to implement different kinds of non-stationary bandits:</span>

<span class="sd">        - Abruptly changing non-stationary bandits, in different variants: changepoints are randomly drawn (once for all ``n`` repetitions or at different location fo each repetition).</span>
<span class="sd">        - Slowly varying non-stationary bandits, where the underlying mean of each arm is slowing randomly modified and a bound on the speed of change (e.g., Lipschitz constant of :math:`t \mapsto \mu_i(t)`) is known.</span>

<span class="sd">    .. warning:: It works fine, but it is still experimental, be careful when using this feature.</span>

<span class="sd">    .. warning:: The number of arms is fixed, see https://github.com/SMPyBandits/SMPyBandits/issues/123 if you are curious about bandit problems with a varying number of arms (or sleeping bandits where some arms can be enabled or disabled at each time).</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="NonStationaryMAB.__init__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.NonStationaryMAB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">VERBOSE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;New NonStationaryMAB.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isChangingAtEachRepetition</span>   <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: The problem is not changing at each repetition.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isDynamic</span>   <span class="o">=</span> <span class="kc">True</span>  <span class="c1">#: The problem is dynamic.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isMarkovian</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1">#: The problem is not Markovian.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="s2">&quot;arm_type&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> <span class="ow">and</span> <span class="s2">&quot;params&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> \
            <span class="ow">and</span> <span class="s2">&quot;newMeans&quot;</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span> \
            <span class="ow">and</span> <span class="s2">&quot;changePoints&quot;</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span> \
            <span class="ow">and</span> <span class="s2">&quot;args&quot;</span> <span class="ow">in</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> \
            <span class="s2">&quot;Error: this NonStationaryMAB is not really a non-stationary MAB, you should use a simple MAB instead!&quot;</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  NonStationary MAB problem, with arm (possibly) changing at every time step, read from a dictionnary &#39;configuration&#39; = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">configuration</span><span class="p">))</span>  <span class="c1"># DEBUG</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">arm_type</span> <span class="o">=</span> <span class="n">arm_type</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;arm_type&quot;</span><span class="p">]</span>  <span class="c1">#: Kind of arm (NonStationaryMAB are homogeneous)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;arm_type&#39; =&quot;</span><span class="p">,</span> <span class="n">arm_type</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;params&#39; =&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newMeans</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;newMeans&quot;</span><span class="p">]</span>  <span class="c1">#: Function to generate the means</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;newMeans&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">newMeans</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;changePoints&quot;</span><span class="p">]</span>  <span class="c1">#: List of the change points</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;changePoints&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onlyOneArm</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;onlyOneArm&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1">#: None by default, but can be &quot;uniform&quot; to only change *one* arm at each change point.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;onlyOneArm&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">onlyOneArm</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span>  <span class="c1">#: Args to give to function</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - with &#39;args&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="c1"># XXX try to read sparsity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">[</span><span class="s2">&quot;sparsity&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;sparsity&quot;</span> <span class="ow">in</span> <span class="n">configuration</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ==&gt; Creating the dynamic arms ...&quot;</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="c1"># Keep track of the successive mean vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># Historic of the means vectors, storing time of {changepoint: newMeans}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Historic of the change points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># nb of calls to the function for generating new arms</span>
        <span class="c1"># Generate a first mean vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">newRandomArms</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - drawing a random set of arms&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>  <span class="c1">#: Means of arms</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - with &#39;nbArms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;   - with &#39;arms&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; - Example of initial draw of &#39;means&#39; =&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">)</span>  <span class="c1"># DEBUG</span></div>

<div class="viewcode-block" id="NonStationaryMAB.reprarms"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.NonStationaryMAB.reprarms">[docs]</a>    <span class="k">def</span> <span class="nf">reprarms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nbPlayers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">openTag</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">endTag</span><span class="o">=</span><span class="s1">&#39;^*&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Cannot represent the dynamic arms, so print the NonStationaryMAB object&quot;&quot;&quot;</span>
        <span class="c1"># print(&quot;reprarms of a NonStationaryMAB object...&quot;)  # DEBUG</span>
        <span class="c1"># print(&quot;  It has self._historyOfMeans =\n{}&quot;.format(self._historyOfMeans))  # DEBUG</span>
        <span class="c1"># print(&quot;  It has self.means =\n{}&quot;.format(self.means))  # DEBUG</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{text}</span><span class="s2">, </span><span class="si">{arm}</span><span class="s2"> with uniform means on [</span><span class="si">{dollar}{lower:.3g}</span><span class="s2">, </span><span class="si">{upper:.3g}{dollar}</span><span class="s2">]</span><span class="si">{mingap}{sparsity}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Non-Stationary MAB&quot;</span><span class="p">,</span>
            <span class="n">arm</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arms</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">lower</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">],</span>
            <span class="n">upper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;lower&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;amplitude&quot;</span><span class="p">],</span>
            <span class="n">mingap</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;mingap&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;mingap&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="sa">r</span><span class="s2">&quot;, min gap=$</span><span class="si">%.3g</span><span class="s2">$&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="s2">&quot;mingap&quot;</span><span class="p">],</span>
            <span class="n">sparsity</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;, sparsity = </span><span class="si">{dollar}{s}{dollar}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sparsity</span><span class="p">,</span> <span class="n">dollar</span><span class="o">=</span><span class="s2">&quot;$&quot;</span> <span class="k">if</span> <span class="n">latex</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">),</span>
            <span class="n">dollar</span><span class="o">=</span><span class="s2">&quot;$&quot;</span> <span class="k">if</span> <span class="n">latex</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">wraptext</span><span class="p">(</span><span class="n">text</span><span class="p">)</span></div>

    <span class="c1">#</span>
    <span class="c1"># --- Dynamic arms and means</span>

<div class="viewcode-block" id="NonStationaryMAB.newRandomArms"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.NonStationaryMAB.newRandomArms">[docs]</a>    <span class="k">def</span> <span class="nf">newRandomArms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">onlyOneArm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">VERBOSE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a new list of arms, from ``arm_type(params[&#39;newMeans&#39;](t, **params[&#39;args&#39;]))``.</span>

<span class="sd">        - If ``onlyOneArm`` is given and is an integer, the change of mean only occurs for this arm and the others stay the same.</span>
<span class="sd">        - If ``onlyOneArm=&quot;uniform&quot;``, the change of mean only occurs for one arm and the others stay the same, and the changing arm is chosen uniformly at random.</span>

<span class="sd">        .. note:: Only the *means* of the arms change (and so, their order), not their family.</span>

<span class="sd">        .. warning:: TODO? So far the only change points we consider is when the means of arms change, but the family of distributions stay the same. I could implement a more generic way, for instance to be able to test algorithms that detect change between different families of distribution (e.g., from a Gaussian of variance=1 to a Gaussian of variance=2, with different or not means).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">changePoints</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)):</span>
            <span class="c1"># return the latest generate means</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">one_draw_of_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newMeans</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># new draw!</span>
        <span class="k">if</span> <span class="n">onlyOneArm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">onlyOneArm</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>  <span class="c1"># - Handling the option to change only one arm</span>
                <span class="n">onlyOneArm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">onlyOneArm</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c1"># - Or a set of arms</span>
                <span class="n">onlyOneArm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">onlyOneArm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">onlyOneArm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">onlyOneArm</span> <span class="o">=</span> <span class="p">[</span><span class="n">onlyOneArm</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">onlyOneArm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">onlyOneArm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">onlyOneArm</span> <span class="o">=</span> <span class="p">[</span><span class="n">onlyOneArm</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>  <span class="c1"># force to extract the list then wrap it back</span>
            <span class="c1"># - If only one arm, and not the first random means, change only one</span>
            <span class="c1"># print(&quot;onlyOneArm =&quot;, onlyOneArm)  # DEBUG</span>
            <span class="k">for</span> <span class="n">arm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">arm</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">onlyOneArm</span><span class="p">:</span>
                    <span class="n">one_draw_of_means</span><span class="p">[</span><span class="n">arm</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]][</span><span class="n">arm</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">one_draw_of_means</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_arms</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arm_type</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span> <span class="k">for</span> <span class="n">mean</span> <span class="ow">in</span> <span class="n">one_draw_of_means</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arms</span><span class="p">)</span>  <span class="c1"># useless</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  - Creating a new dynamic list of means = </span><span class="si">{}</span><span class="s2"> for arms: NonStationaryMAB = </span><span class="si">{}</span><span class="s2"> ...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">one_draw_of_means</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>  <span class="c1"># DEBUG</span>
            <span class="c1"># print(&quot;Currently self._t = {} and self._historyOfMeans = {} ...&quot;.format(self._t, self._historyOfMeans))  # DEBUG</span>
        <span class="k">return</span> <span class="n">one_draw_of_means</span></div>

<div class="viewcode-block" id="NonStationaryMAB.get_minArm"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.NonStationaryMAB.get_minArm">[docs]</a>    <span class="k">def</span> <span class="nf">get_minArm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the smallest mean of the arms, for a non-stationary MAB</span>

<span class="sd">        - It is a vector of length horizon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">horizon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">horizon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)</span>
        <span class="n">mapOfMinArms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">min</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">[</span><span class="n">tau</span><span class="p">])</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)]</span>
        <span class="n">meansOfMinArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">horizon</span><span class="p">)</span>
        <span class="n">nbChangePoint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">horizon</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nbChangePoint</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">[</span><span class="n">nbChangePoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">nbChangePoint</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">meansOfMinArms</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapOfMinArms</span><span class="p">[</span><span class="n">nbChangePoint</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">meansOfMinArms</span></div>

<div class="viewcode-block" id="NonStationaryMAB.get_maxArm"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.NonStationaryMAB.get_maxArm">[docs]</a>    <span class="k">def</span> <span class="nf">get_maxArm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vector of max mean of the arms, for a non-stationary MAB.</span>

<span class="sd">        - It is a vector of length horizon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">horizon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">horizon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)</span>
        <span class="n">mapOfMaxArms</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">[</span><span class="n">tau</span><span class="p">])</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)]</span>
        <span class="n">meansOfMaxArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">horizon</span><span class="p">)</span>
        <span class="n">nbChangePoint</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">horizon</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nbChangePoint</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">[</span><span class="n">nbChangePoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">nbChangePoint</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">meansOfMaxArms</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapOfMaxArms</span><span class="p">[</span><span class="n">nbChangePoint</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">meansOfMaxArms</span></div>

<div class="viewcode-block" id="NonStationaryMAB.get_allMeans"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.NonStationaryMAB.get_allMeans">[docs]</a>    <span class="k">def</span> <span class="nf">get_allMeans</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">horizon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the vector of mean of the arms, for a non-stationary MAB.</span>

<span class="sd">        - It is a numpy array of shape (nbArms, horizon).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">horizon</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">horizon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)</span>
        <span class="n">mapOfArms</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfMeans</span><span class="p">[</span><span class="n">tau</span><span class="p">]</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)]</span>
        <span class="n">meansOfArms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">,</span> <span class="n">horizon</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">armId</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbArms</span><span class="p">):</span>
            <span class="n">nbChangePoint</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">horizon</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nbChangePoint</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_historyOfChangePoints</span><span class="p">[</span><span class="n">nbChangePoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">nbChangePoint</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">meansOfArms</span><span class="p">[</span><span class="n">armId</span><span class="p">][</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapOfArms</span><span class="p">[</span><span class="n">nbChangePoint</span><span class="p">][</span><span class="n">armId</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">meansOfArms</span></div></div>


<span class="c1"># --- IncreasingMAB</span>


<div class="viewcode-block" id="static_change_lower_amplitude"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.static_change_lower_amplitude">[docs]</a><span class="k">def</span> <span class="nf">static_change_lower_amplitude</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l_t</span><span class="p">,</span> <span class="n">a_t</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A function called by :class:`IncreasingMAB` *at every time t*, to compute the (possibly) knew values for :math:`l_t` and :math:`a_t`.</span>

<span class="sd">    - First argument is a boolean, `True` if a change occurred, `False` otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">l_t</span><span class="p">,</span> <span class="n">a_t</span></div>


<span class="c1">#: Default value for the :func:`doubling_change_lower_amplitude` function.</span>
<span class="n">L0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">DELTA_T</span><span class="p">,</span> <span class="n">ZOOM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mf">1.1</span>
<span class="n">L0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">DELTA_T</span><span class="p">,</span> <span class="n">ZOOM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mf">1.05</span>
<span class="n">L0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">DELTA_T</span><span class="p">,</span> <span class="n">ZOOM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2500</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">L0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">DELTA_T</span><span class="p">,</span> <span class="n">ZOOM</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">L0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">DELTA_T</span><span class="p">,</span> <span class="n">ZOOM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">L0</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">DELTA</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">DELTA_T</span><span class="p">,</span> <span class="n">ZOOM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>


<div class="viewcode-block" id="doubling_change_lower_amplitude"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.doubling_change_lower_amplitude">[docs]</a><span class="k">def</span> <span class="nf">doubling_change_lower_amplitude</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l_t</span><span class="p">,</span> <span class="n">a_t</span><span class="p">,</span> <span class="n">l0</span><span class="o">=</span><span class="n">L0</span><span class="p">,</span> <span class="n">a0</span><span class="o">=</span><span class="n">A0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="n">DELTA</span><span class="p">,</span> <span class="n">T0</span><span class="o">=</span><span class="n">T0</span><span class="p">,</span> <span class="n">deltaT</span><span class="o">=</span><span class="n">DELTA_T</span><span class="p">,</span> <span class="n">zoom</span><span class="o">=</span><span class="n">ZOOM</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;A function called by :class:`IncreasingMAB` *at every time t*, to compute the (possibly) knew values for :math:`l_t` and :math:`a_t`.</span>

<span class="sd">    - At time 0, it forces to use :math:`l_0, a_0` if they are given and not ``None``.</span>
<span class="sd">    - At step `T0`, it reduces :math:`l_t` by `delta` (typically from `0` to `-1`).</span>
<span class="sd">    - Every `deltaT` steps, it multiplies both  :math:`l_t` and :math:`a_t` by `zoom`.</span>
<span class="sd">    - First argument is a boolean, `True` if a change occurred, `False` otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">l0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">a0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">different_starting</span> <span class="o">=</span> <span class="p">(</span><span class="n">l_t</span> <span class="o">!=</span> <span class="n">l0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">a_t</span> <span class="o">!=</span> <span class="n">a0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l_t</span> <span class="o">=</span> <span class="n">l0</span>
        <span class="k">if</span> <span class="n">a0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">a_t</span> <span class="o">=</span> <span class="n">a0</span>
        <span class="k">return</span> <span class="n">different_starting</span><span class="p">,</span> <span class="n">l_t</span><span class="p">,</span> <span class="n">a_t</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">T0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">delta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">l_t</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">a_t</span>
        <span class="k">elif</span> <span class="n">deltaT</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">%</span> <span class="n">deltaT</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">zoom</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">zoom</span> <span class="o">*</span> <span class="n">l_t</span><span class="p">,</span> <span class="n">zoom</span> <span class="o">*</span> <span class="n">a_t</span>
    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">l_t</span><span class="p">,</span> <span class="n">a_t</span></div>


<span class="n">default_change_lower_amplitude</span> <span class="o">=</span> <span class="n">doubling_change_lower_amplitude</span>


<div class="viewcode-block" id="IncreasingMAB"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.IncreasingMAB">[docs]</a><span class="k">class</span> <span class="nc">IncreasingMAB</span><span class="p">(</span><span class="n">MAB</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Like a stationary MAB problem, but the range of the rewards is increased from time to time, to test the :class:`Policy.WrapRange` policy.</span>

<span class="sd">    - M.arms and M.means is NOT changed after each call to ``newRandomArms()``, but not nbArm.</span>

<span class="sd">    .. warning:: It is purely experimental, be careful when using this feature.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="IncreasingMAB.__init__"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.IncreasingMAB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">configuration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;New MAB.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">IncreasingMAB</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">configuration</span><span class="p">)</span>
        <span class="c1"># XXX Expects a function of (t, lower, amplitude) that gives the new (lower, amplitude)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isDynamic</span>   <span class="o">=</span> <span class="kc">True</span>  <span class="c1">#: Flag to know if the problem is static or not.</span>
        <span class="c1"># WARNING the hash function used on configuration dictionary don&#39;t like to have non-hashable part in the dictionary keys, I need to fix that</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">configuration</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_change_lower_amplitude</span> <span class="o">=</span> <span class="n">configuration</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;change_lower_amplitude&quot;</span><span class="p">,</span> <span class="n">default_change_lower_amplitude</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_lower_amplitude</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_change_lower_amplitude</span> <span class="o">=</span> <span class="n">default_change_lower_amplitude</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_change_lower_amplitude</span> <span class="o">=</span> <span class="n">default_change_lower_amplitude</span>
        <span class="c1"># Compute the first lower and amplitude values</span>
        <span class="n">lowers</span><span class="p">,</span> <span class="n">amplitudes</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">:</span>
            <span class="n">l</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">lower_amplitude</span>
            <span class="n">lowers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">amplitudes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_lowers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lowers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lowers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lowers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span></div>

<div class="viewcode-block" id="IncreasingMAB.draw"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.IncreasingMAB.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">armId</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return a random sample from the armId-th arm, at time t. Usually t is not used.&quot;&quot;&quot;</span>
        <span class="n">l_t</span><span class="p">,</span> <span class="n">a_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lowers</span><span class="p">[</span><span class="n">armId</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_amplitudes</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span>
        <span class="n">haschanged</span><span class="p">,</span> <span class="n">l_tp1</span><span class="p">,</span> <span class="n">a_tp1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_change_lower_amplitude</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">l_t</span><span class="p">,</span> <span class="n">a_t</span><span class="p">)</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">haschanged</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: for </span><span class="si">{}</span><span class="s2">, current l_t, a_t values for arm </span><span class="si">{}</span><span class="s2"> have changed, from </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arms</span><span class="p">[</span><span class="n">armId</span><span class="p">],</span> <span class="n">l_t</span><span class="p">,</span> <span class="n">a_t</span><span class="p">,</span> <span class="n">l_tp1</span><span class="p">,</span> <span class="n">a_tp1</span><span class="p">))</span>  <span class="c1"># DEBUG</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lowers</span><span class="p">[</span><span class="n">armId</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_amplitudes</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span> <span class="o">=</span> <span class="n">l_tp1</span><span class="p">,</span> <span class="n">a_tp1</span>
        <span class="n">l_of_a</span><span class="p">,</span> <span class="n">a_of_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_lowers</span><span class="p">[</span><span class="n">armId</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_amplitudes</span><span class="p">[</span><span class="n">armId</span><span class="p">]</span>
        <span class="c1"># scale it to [0, 1]?</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="p">(</span><span class="n">reward</span> <span class="o">-</span> <span class="n">l_of_a</span><span class="p">)</span> <span class="o">/</span> <span class="n">a_of_a</span>
        <span class="c1"># now unscale it in the new interval</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="n">l_tp1</span> <span class="o">+</span> <span class="n">reward</span> <span class="o">*</span> <span class="n">a_tp1</span>
        <span class="c1"># finally, be done and return it</span>
        <span class="k">assert</span> <span class="n">l_tp1</span> <span class="o">&lt;=</span> <span class="n">reward</span> <span class="o">&lt;=</span> <span class="n">l_tp1</span> <span class="o">+</span> <span class="n">a_tp1</span><span class="p">,</span> <span class="s2">&quot;Error: the new rescaled reward </span><span class="si">{:.3g}</span><span class="s2"> is not in [</span><span class="si">{:.3g}</span><span class="s2">, </span><span class="si">{:.3g}</span><span class="s2">]... that shouldn&#39;t be possible!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reward</span><span class="p">,</span> <span class="n">l_tp1</span><span class="p">,</span> <span class="n">l_tp1</span> <span class="o">+</span> <span class="n">a_tp1</span><span class="p">)</span>  <span class="c1"># DEBUG</span>
        <span class="k">return</span> <span class="n">reward</span></div></div>


<span class="c1"># --- Utility functions</span>

<div class="viewcode-block" id="binomialCoefficient"><a class="viewcode-back" href="../../docs/Environment.MAB.html#Environment.MAB.binomialCoefficient">[docs]</a><span class="k">def</span> <span class="nf">binomialCoefficient</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Compute a binomial coefficient :math:`C^n_k` by a direct multiplicative method: :math:`C^n_k = {k \choose n}`.</span>

<span class="sd">    - Exact, using integers, not like https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.binom.html#scipy.special.binom which uses float numbers.</span>
<span class="sd">    - Complexity: :math`\mathcal{O}(1)` in memory, :math`\mathcal{O}(n)` in time.</span>
<span class="sd">    - From https://en.wikipedia.org/wiki/Binomial_coefficient#Binomial_coefficient_in_programming_languages</span>
<span class="sd">    - From: http://userpages.umbc.edu/~rcampbel/Computers/Python/probstat.html#ProbStat-Combin-Combinations</span>

<span class="sd">    - Examples:</span>

<span class="sd">    &gt;&gt;&gt; binomialCoefficient(-3, 10)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; binomialCoefficient(1, -10)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; binomialCoefficient(1, 10)</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; binomialCoefficient(5, 10)</span>
<span class="sd">    80</span>
<span class="sd">    &gt;&gt;&gt; binomialCoefficient(5, 20)</span>
<span class="sd">    12960</span>
<span class="sd">    &gt;&gt;&gt; binomialCoefficient(10, 30)</span>
<span class="sd">    10886400</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>  <span class="c1"># take advantage of symmetry</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">*=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c</span></div>


<span class="c1"># --- Debugging</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Code for debugging purposes.</span>
    <span class="kn">from</span> <span class="nn">doctest</span> <span class="k">import</span> <span class="n">testmod</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Testing automatically all the docstring written in each functions of this module :&quot;</span><span class="p">)</span>
    <span class="n">testmod</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016-2018, Lilian Besson (Naereen)
      Last updated on 19 Feb 2019, 12h.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>